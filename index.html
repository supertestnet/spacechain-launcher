<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
	    <style>
                * {
                    box-sizing: border-box;
                    font-size: 1.15rem;
                    font-family: Arial, sans-serif;
                }
                html {
                    max-width: 70ch;
                    padding: 3rem 1rem;
                    margin: auto;
                    line-height: 1.25;
                }
                h1 {
                    font-size: 2rem;
                }
                h2 {
                    font-size: 1.5rem;
                }
                input, textarea {
                    line-height: 1.25;
                    width: 100%;
                    height: 1.8rem;
                    font-size: 1.15rem;
                    border: 1px solid grey;
                }
                textarea {
                    height: auto;
                }
                .launch_page, .genesis_block_finalized, .payment_div_container, .new_block_payment_div_container,
                .prelaunchpad, .spaceblock_explorer, .mining_center, .behold_the_network, .launch_instructions,
                .buy_and_sell_spacecoins, .pegzone, .spacecoin_offer, .burn_payment_div_container,
                .hidden_mining_info, .manage_your_wallet, .spacechain_wallet, .spacecoin_payment_div_container,
                .send_money_form {
                    display: none;
                }
                .genesis_block_finalized .genesis_block_title {
                    text-align: center;
                    width: 400px;
                }
                .genesis_block_finalized .genesis_block p,
                .genesis_block_finalized .genesis_block input,
                .genesis_block_finalized .genesis_block textarea {
                    text-align: center;
                }
                .genesis_block_finalized .genesis_block input,
                .genesis_block_finalized .genesis_block textarea {
                    background-color: #aaa;
                    color: white;
                }
                .genesis_block {
                    width: 400px;
                    height: 400px;
                    border: 1px solid black;
                    padding: 10px;
                    display: flex;
                    flex-direction: column;
                }
                .payment_div, .new_block_payment_div, .burn_payment_div, .spacecoin_payment_div {
                    max-width: 400px;
                    border: 1px solid black;
                }
                .qr_code {
                    width: 100%;
                }
                .launch_payment_caption_container, .new_block_payment_caption_container,
                .burn_payment_caption_container, .spacecoin_payment_caption_container {
                    margin-top: -20px;
                    margin-bottom: 20px;
                }
                .launch_payment_caption, .new_block_payment_caption, .burn_payment_caption,
                .spacecoin_payment_caption {
                    display: inline-block;
                    box-sizing: border-box;
                    width: calc( 90% - 40px );
                    height: 40px;
                    font-family: monospace;
                    color: black;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    border: 1px solid black;
                    padding: 5px;
                    vertical-align: middle;
                    margin-left: 10px;
                }
                .launch_payment_copier, .new_block_payment_copier, .burn_payment_copier,
                .spacecoin_payment_copier {
                    box-sizing: border-box;
                    margin-left: 10px;
                    margin-right: 10px;
                    vertical-align: middle;
                    width: 10%;
                    height: 40px;
                }
                .launchpad {
                    display: flex;
                    justify-content: space-between;
                }
                .launchpad button {
                    margin: 5px;
                }
                .spaceblocks p {
                    word-wrap: break-word;
                }
	    </style>
        <script src="https://bitcoincore.tech/apps/bitcoinjs-ui/lib/bitcoinjs-lib.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/merkletreejs@latest/merkletree.js"></script>
        <script src="https://supertestnet.github.io/bitcoin-chess/js/qrcode.js"></script>
        <script src="https://bundle.run/browserify-cipher@1.0.1"></script>
        <script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
        <script src="https://bundle.run/varuint-bitcoin@1.1.2"></script>
        <script src="https://bundle.run/buffer@6.0.3"></script>
        <script src="https://bundle.run/bech32@2.0.0"></script>
        <script src="https://bundle.run/bip39@3.0.4"></script>
        <script src="https://bundle.run/bip32@2.0.6"></script>
        <script>var Buffer = buffer.Buffer;</script>
        <script>
            var $ = document.querySelector.bind( document );
            var $$ = document.querySelectorAll.bind( document );
            var url_params = new URLSearchParams( window.location.search );
            var url_keys = url_params.keys()
            var $_GET = {}
            var spacechain = [];
            var last_block_synced = 0;
            if ( localStorage[ "last_block_synced" ] ) {
                last_block_synced = Number( localStorage[ "last_block_synced" ] );
            } else {
                localStorage[ "last_block_synced" ] = last_block_synced;
            }
            var sync_in_progress = false;
            if ( localStorage[ "spacechain" ] ) {
                spacechain = JSON.parse( localStorage[ "spacechain" ] );
            }
            var anchor_utxos_in_my_spacechain = [];
            if ( localStorage[ "anchor_utxos_in_my_spacechain" ] ) {
                anchor_utxos_in_my_spacechain = JSON.parse( localStorage[ "anchor_utxos_in_my_spacechain" ] );
            }
            for ( var key of url_keys ) $_GET[ key ] = url_params.get( key );
            var allminers = [];
            var myminers = [];
            var pending_block_requests = [];
            sessionStorage.clear();
            if ( $_GET[ "mining" ] == "true" ) {
                sessionStorage[ "mining" ] = true;
            }
            sessionStorage[ "block_after_theft" ] = "";
            sessionStorage[ "block_being_sought" ] = "";
            sessionStorage[ "userdata" ] = "[]";
            if ( !localStorage[ "backup_words" ] ) {
                localStorage[ "backup_words" ] = bip39.generateMnemonic();
            }
            async function view_offer() {
                $( '.home' ).style.display = "none";
                $( '.launch_step_1' ).style.display = "none";
                $( '.launch_step_2' ).style.display = "none";
                $( '.launch_instructions' ).style.display = "none";
                $( '.step_3_title' ).style.display = "none";
                $( '.spaceblock_explorer' ).style.display = "none";
                $( '.mining_center' ).style.display = "none";
                $( '.pegzone' ).style.display = "none";
                $( '.spacecoin_offer' ).style.display = "block";
                if ( $_GET[ "offer" ] == "25594d702f285977c5c127bb4b6dc9564b73f82ae67a39b5ec8743ffbba554d6" ) {
                    var offer = document.createElement( "div" );
                    offer.style = "border: 1px solid black; padding: 10px; margin: 10px;";
                    offer.className = "sell_offer";
                    var pgraph = document.createElement( "p" );
                    pgraph.innerHTML = `Seller: <span class="buyer">The Void</span>`;
                    offer.append( pgraph );
                    var pgraph = document.createElement( "p" );
                    pgraph.innerHTML = `Amount: <span class="min">546</span> - <span class="max">100,000,000,000</span> sats`;
                    offer.append( pgraph );
                    var pgraph = document.createElement( "p" );
                    pgraph.innerHTML = `Fee type: <span class="orderbook_fee_type">Absolute</span>`;
                    offer.append( pgraph );
                    var pgraph = document.createElement( "p" );
                    pgraph.innerHTML = `Fee: <span class="orderbook_fee">loading...</span>`;
                    offer.append( pgraph );
                    $( '.offer_details' ).append( offer );
                    $( '.spacecoins_to_buy' ).max = 100000000000;
                    var feerate = await getMinFeeRate();
                    var fee = 300 * feerate;
                    $( '.orderbook_fee' ).innerText = String( fee ) + " sats";
                }
            }
            function view_network_home() {
                $( '.home' ).style.display = "none";
                $( '.launch_step_1' ).style.display = "none";
                $( '.launch_step_2' ).style.display = "none";
                $( '.launch_instructions' ).style.display = "none";
                $( '.step_3_title' ).style.display = "none";
                $( '.spaceblock_explorer' ).style.display = "none";
                $( '.mining_center' ).style.display = "none";
                $( '.pegzone' ).style.display = "none";
                $( '.spacecoin_offer' ).style.display = "none";
                $( '.spacechain_wallet' ).style.display = "none";
                $( '.behold_the_network' ).style.display = "block";
                $( '.launch_page' ).style.display = "block";
                $( '.prelaunchpad' ).style.display = "block";
                $( '.launch_step_3' ).style.display = "block";
                var num_of_miners = myminers.length;
                $( '.num_of_miners' ).innerText = myminers.length;
                if ( num_of_miners == 1 ) {
                    $( '.is_or_are' ).innerText = "is";                    
                }
                if ( num_of_miners == 1 ) {
                    $( '.person_or_people' ).innerText = "person";                    
                }
                if ( !$_GET[ "wallet_id" ] ) return;
                $( '.manage_your_wallet' ).style.display = "inline";
                $( '.buy_and_sell_spacecoins' ).style.display = "inline";
            }
            var chain_til_theft_or_blockheight = [];
            if ( $_GET[ "chain" ] && !$_GET[ "offer" ] ) {
                //the next line syncs headers until the first theft, if any
                chain_til_theft_or_blockheight.push( $_GET[ "chain" ] );
                window.onload = view_network_home;
            }
            if ( $_GET[ "offer" ] ) {
                window.onload = view_offer;
            }
            if ( $_GET[ "chain" ] && anchor_utxos_in_my_spacechain[ 0 ] != $_GET[ "chain" ] ) {
                anchor_utxos_in_my_spacechain = [];
                anchor_utxos_in_my_spacechain.push( $_GET[ "chain" ] );
                localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
            }
            //internet functions
            async function getData( url ) {
                var rtext = "";
                function inner_get( url ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.open( "GET", url, true );
                    xhttp.send();
                    return xhttp;
                }
                var data = inner_get( url );
                data.onerror = function( e ) {
                    rtext = "error";
                }
                async function isResponseReady() {
                    return new Promise( function( resolve, reject ) {
                        if ( rtext == "error" ) {
                            resolve( rtext );
                        }
                        if ( !data.responseText || data.readyState != 4 ) {
                            setTimeout( async function() {
                                var msg = await isResponseReady();
                                resolve( msg );
                            }, 50 );
                        } else {
                            resolve( data.responseText );
                        }
                    });
                }
                var returnable = await isResponseReady();
                return returnable;
            }
            // function postData( url, json, content_type = "", apikey = "" ) {
            //     return new Promise( function( resolve, reject ) {
            //         var xhttp = new XMLHttpRequest();
            //         xhttp.onreadystatechange = function() {
            //             if ( this.readyState == 4 && ( this.status >= 200 && this.status < 300 ) ) {
            //                 resolve( xhttp.responseText );
            //             }
            //         }
            //         xhttp.open( `POST`, url, true );
            //         if ( content_type ) {
            //             xhttp.setRequestHeader( `Content-Type`, content_type );
            //         }
            //         if ( apikey ) {
            //             xhttp.setRequestHeader( `X-Api-Key`, apikey );
            //         }
            //         xhttp.send( json );
            //     });
            // }
            async function postData( url, json, content_type = "", apikey = "" ) {
                var rtext = "";
                function inner_post( url, json, content_type = "", apikey = "" ) {
                    var xhttp = new XMLHttpRequest();
                    xhttp.open( "POST", url, true );
                    if ( content_type ) {
                        xhttp.setRequestHeader( `Content-Type`, content_type );
                    }
                    if ( apikey ) {
                        xhttp.setRequestHeader( `X-Api-Key`, apikey );
                    }
                    xhttp.send( json );
                    return xhttp;
                }
                var data = inner_post( url, json, content_type, apikey );
                data.onerror = function( e ) {
                    rtext = "error";
                }
                async function isResponseReady() {
                    return new Promise( function( resolve, reject ) {
                        if ( rtext == "error" ) {
                            resolve( rtext );
                        }
                        if ( !data.responseText || data.readyState != 4 ) {
                            setTimeout( async function() {
                                var msg = await isResponseReady();
                                resolve( msg );
                            }, 50 );
                        } else {
                            resolve( data.responseText );
                        }
                    });
                }
                var returnable = await isResponseReady();
                return returnable;
            }
            function waitSomeSeconds( num ) {
                var num = num.toString() + "000";
                num = Number( num );
                return new Promise( function( resolve, reject ) {
                    setTimeout( function() { resolve( "" ); }, num );
                });
            }
            async function getNote( item ) {
                async function isNoteSetYet( note_i_seek ) {
                    return new Promise( function( resolve, reject ) {
                        if ( !note_i_seek ) {
                            setTimeout( async function() {
                                var msg = await isNoteSetYet( sessionStorage[ item ] );
                                resolve( msg );
                            }, 100 );
                        } else {
                            resolve( note_i_seek );
                        }
                    });
                }
                async function getTimeoutData() {
                    var note_i_seek = await isNoteSetYet( sessionStorage[ item ] );
                    return note_i_seek;
                }
                var returnable = await getTimeoutData();
                return returnable;
            }
            //end of internet functions
            //bitcoin functions
            async function pushBTCpmt( rawtx ) {
                var txid = await postData( "https://mempool.space/testnet/api/tx", rawtx );
                if ( txid.includes( "error" ) ) {
                    alert( `Something terrible happened while trying to send your transaction, it was rejected by the node you sent it to. In case you want to try to recover the money, the private key is in sessionStorage[ "utxo_data" ] and the redeemscript you need to redeem the money can be recreated using the source code of this html page. (You'll have to learn how to use bitcoin-js though so you may want to ask a developer for help.)` );
                    return;
                }
                return txid;
            }
            async function getMinFeeRate() {
                var fees = await getData( "https://mempool.space/testnet/api/v1/fees/recommended" );
                fees = JSON.parse( fees );
                if ( !( "minimumFee" in fees ) ) return "error -- site down";
                var minfee = fees[ "minimumFee" ];
                return minfee;
            }
            async function getBlockheight() {
                var data = await getData( "https://mempool.space/testnet/api/blocks/tip/height" );
                return Number( data );
            }
            function textToHex( text ) {
                var encoder = new TextEncoder().encode( text );
                return [...new Uint8Array(encoder)]
                    .map(x => x.toString(16).padStart(2, '0'))
                    .join('');
            }
            function hexToBytes( hex ) {
                return Uint8Array.from( hex.match( /.{1,2}/g ).map( ( byte ) => parseInt( byte, 16 ) ) );
            }
            function bytesToHex( bytes ) {
                return bytes.reduce( ( str, byte ) => str + byte.toString( 16 ).padStart( 2, '0' ), '' );
            }
            function hexToText( hex ) {
                var bytes = new Uint8Array(Math.ceil(hex.length / 2));
                for (var i = 0; i < hex.length; i++) bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
                var text = new TextDecoder().decode( bytes );
                return text;
            }
            function base64ToHex( str ) {
                var raw = atob( str );
                var result = '';
                var i; for ( i=0; i<raw.length; i++ ) {
                    var hex = raw.charCodeAt( i ).toString( 16 );
                    result += ( hex.length === 2 ? hex : '0' + hex );
                }
                return result;
            }
            function hexToBech32( prefix, hex ) {
                var words = bech32.bech32m.toWords( hexToBytes( hex ) );
                return bech32.bech32m.encode( prefix, words );
            }

            function bech32ToHex( bech32string ) {
                var decoded = bech32.bech32m.fromWords( bech32.bech32m.decode( bech32string ).words );
                return bytesToHex( decoded );
            }
            function witnessStackToScriptWitness(witness) {
                let buffer2 = Buffer.allocUnsafe(0);
                function writeSlice(slice) {
                    buffer2 = Buffer.concat([buffer2, Buffer.from(slice)]);
                }
                function writeVarInt(i) {
                    const currentLen = buffer2.length;
                    const varintLen = varuintBitcoin.encodingLength(i);
                    buffer2 = Buffer.concat([buffer2, Buffer.allocUnsafe(varintLen)]);
                    varuintBitcoin.encode(i, buffer2, currentLen);
                }
                function writeVarSlice(slice) {
                    writeVarInt(slice.length);
                    writeSlice(slice);
                }
                function writeVector(vector) {
                    writeVarInt(vector.length);
                    vector.forEach(writeVarSlice);
                }
                writeVector(witness);
                return buffer2;
            }
            function generateHtlcWithServerTimelocked( serverPubkey, userPubkey, pmthash, timelock ) {
                return bitcoinjs.script.fromASM(
                    `
                        OP_DROP
                        OP_SHA256
                        ${ pmthash }
                        OP_EQUAL
                        OP_IF
                            ${ userPubkey }
                        OP_ELSE
                            ${ bitcoinjs.script.number.encode( timelock ).toString( "hex" ) }
                            OP_CHECKLOCKTIMEVERIFY
                            OP_DROP
                            ${ serverPubkey }
                        OP_ENDIF
                        OP_CHECKSIG
                    `
                    .trim()
                    .replace( /\s+/g, ' ' ),
                );
            }
            function generateAnchorOutput() {
                return bitcoinjs.script.fromASM(
                    `
                        OP_DROP
                        OP_1
                        OP_CHECKSEQUENCEVERIFY
                        OP_DROP
                        OP_1
                    `
                    .trim()
                    .replace(/\s+/g, ' '),
                );
            }
            function getSwapAddress( serverPubkey, userPubkey, pmthash, timelock ) {
                var witnessscript = generateHtlcWithServerTimelocked( serverPubkey, userPubkey, pmthash, timelock );
                var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                return p2wsh.address;
            }
            async function getUTXOsInAddress( address, privkey, pubkey ) {
                if ( !privkey ) {
                    privkey = "";
                }
                if ( !pubkey ) {
                    pubkey = "";
                }
                var esplorautxos = await getData( "https://blockstream.info/testnet/api/address/" + address + "/utxo" );
                esplorautxos = JSON.parse( esplorautxos );
                var obj = [];
                esplorautxos.forEach( function( item, index ) {
                    var utxo = {}
                    utxo[ "tx_id" ] = item[ "txid" ];
                    utxo[ "output_number" ] = item[ "vout" ];
                    utxo[ "amount" ] = item[ "value" ];
                    utxo[ "privkey" ] = privkey;
                    utxo[ "pubkey" ] = pubkey;
                    obj.push( utxo );
                });
                return( obj );
            }

            async function addressHasOneUtxoOfRightAmount( address, amount, privkey, pubkey ) {
                var utxos = await getUTXOsInAddress( address, privkey, pubkey );
                if ( utxos.length != 1 ) return;
                if ( utxos[ 0 ][ "amount" ] != amount ) return;
                return true;
            }
            async function utxoIsReady( address, amount, privkey, pubkey ) {
                var note = await addressHasOneUtxoOfRightAmount( address, amount, privkey, pubkey );
                async function isResponseReady() {
                    return new Promise( function( resolve, reject ) {
                        if ( !note ) {
                            setTimeout( async function() {
                                console.log( "waiting..." );
                                var msg = await utxoIsReady( address, amount, privkey, pubkey );
                                resolve( msg );
                            }, 5000 );
                        } else {
                            resolve( note );
                        }
                    });
                }
                var returnable = await isResponseReady();
                return returnable;
            }
            function getRawTxThatMakesAnchorOutputFromSwapAddress( utxo, timelock, serverPubkey, pmthash, anchor_address, spaceblock_hash, preimage ) {
                console.log( "spaceblock hash:", spaceblock_hash, "preimage:", preimage );
                var userPubkey = utxo[ "pubkey" ];
                var witnessscript = generateHtlcWithServerTimelocked( serverPubkey, userPubkey, pmthash, timelock );
                //the utxo object is used like this: utxo[ "tx_id" ], utxo[ "output_number" ],
                //utxo[ "amount" ], utxo[ "privkey" ], utxo[ "pubkey" ]
                var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
                psbt.addInput({
                  hash: utxo[ "tx_id" ],
                  index: utxo[ "output_number" ],
                  sequence: 0xfffffffe,
                  witnessUtxo: {
                    script: Buffer.from( '0020' +
                      bitcoinjs.crypto.sha256( Buffer.from( witnessscript, "hex" ) ).toString( "hex" ), "hex" ),
                    value: utxo[ "amount" ]
                  },
                  witnessScript: Buffer.from( witnessscript, "hex" )
                });
                psbt.addOutput({
                  address: anchor_address,
                  value: 546,
                });
                psbt.signInput( 0, bitcoinjs.ECPair.fromPrivateKey( Buffer.from( utxo[ "privkey" ], "hex" ) ) );

                var getFinalScripts = ( txindex, input, script ) => {
                  // Step 1: Check to make sure the meaningful locking script matches what you expect.
                  var decompiled = bitcoinjs.script.decompile( script )
                  if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_DROP ) {
                    throw new Error( `Can not finalize input #${txindex}` )
                  }

                  // Step 2: Create final scripts
                  var witnessStackClaimBranch = bitcoinjs.payments.p2wsh({
                    redeem: {
                      output: script,
                      input: bitcoinjs.script.compile([
                        input.partialSig[ 0 ].signature,
                        Buffer.from( preimage, "hex" ),
                        Buffer.from( spaceblock_hash, "hex" ),
                      ]),
                    }
                  });
                  return {
                    finalScriptWitness: witnessStackToScriptWitness( witnessStackClaimBranch.witness )
                  }
                }
                psbt.finalizeInput( 0, getFinalScripts );
                return psbt.extractTransaction().toHex();
            }
            function getRawTxThatMovesAnchorOutput( new_utxo, anchor_txid, timelock, serverPubkey, pmthash, anchor_address, spaceblock_hash, preimage ) {
                console.log( "spaceblock hash:", spaceblock_hash, "preimage:", preimage );
                var userPubkey = new_utxo[ "pubkey" ];
                var witnessscript = generateHtlcWithServerTimelocked( serverPubkey, userPubkey, pmthash, timelock );
                var anchor_witnessscript = generateAnchorOutput();
                var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
                psbt.addInput({
                  hash: anchor_txid,
                  index: 0,
                  sequence: 1,
                  witnessUtxo: {
                    script: Buffer.from( '0020' +
                      bitcoinjs.crypto.sha256( Buffer.from( anchor_witnessscript, "hex" ) ).toString( "hex" ), "hex" ),
                    value: 546
                  },
                  witnessScript: Buffer.from( anchor_witnessscript, "hex" )
                });
                psbt.addInput({
                  hash: new_utxo[ "tx_id" ],
                  index: new_utxo[ "output_number" ],
                  sequence: 0xfffffffe,
                  witnessUtxo: {
                    script: Buffer.from( '0020' +
                      bitcoinjs.crypto.sha256( Buffer.from( witnessscript, "hex" ) ).toString( "hex" ), "hex" ),
                    value: new_utxo[ "amount" ]
                  },
                  witnessScript: Buffer.from( witnessscript, "hex" )
                });
                psbt.addOutput({
                  address: anchor_address,
                  value: 546,
                });
                psbt.signInput( 1, bitcoinjs.ECPair.fromPrivateKey( Buffer.from( new_utxo[ "privkey" ], "hex" ) ) );

                var getFinalScripts1 = ( txindex, input, script ) => {
                  // Step 1: Check to make sure the meaningful locking script matches what you expect.
                  var decompiled = bitcoinjs.script.decompile( script )
                  if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_DROP ) {
                    throw new Error( `Can not finalize input #${txindex}` )
                  }

                  // Step 2: Create final scripts
                  var witnessStackClaimBranch = bitcoinjs.payments.p2wsh({
                    redeem: {
                      output: script,
                      input: bitcoinjs.script.compile([
                        Buffer.from( spaceblock_hash, "hex" ),
                      ]),
                    }
                  });
                  return {
                    finalScriptWitness: witnessStackToScriptWitness( witnessStackClaimBranch.witness )
                  }
                }

                var getFinalScripts2 = ( txindex, input, script ) => {
                  // Step 1: Check to make sure the meaningful locking script matches what you expect.
                  var decompiled = bitcoinjs.script.decompile( script )
                  if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_DROP ) {
                    throw new Error( `Can not finalize input #${txindex}` )
                  }

                  // Step 2: Create final scripts
                  var witnessStackClaimBranch = bitcoinjs.payments.p2wsh({
                    redeem: {
                      output: script,
                      input: bitcoinjs.script.compile([
                        input.partialSig[ 0 ].signature,
                        Buffer.from( preimage, "hex" ),
                        Buffer.from( "", "hex" ),
                      ]),
                    }
                  });
                  return {
                    finalScriptWitness: witnessStackToScriptWitness( witnessStackClaimBranch.witness )
                  }
                }
                psbt.finalizeInput( 0, getFinalScripts1 );
                psbt.finalizeInput( 1, getFinalScripts2 );
                return psbt.extractTransaction().toHex();
            }
            function getRawTxThatMakesAnOpReturn( utxo, timelock, serverPubkey, pmthash, op_return, preimage, amount_to_burn ) {
                var data = Buffer.from( op_return, "hex" );
                var embed = bitcoinjs.payments.embed({data: [data], network: bitcoinjs.networks.testnet});
                var userPubkey = utxo[ "pubkey" ];
                var witnessscript = generateHtlcWithServerTimelocked( serverPubkey, userPubkey, pmthash, timelock );
                //the utxo object is used like this: utxo[ "tx_id" ], utxo[ "output_number" ],
                //utxo[ "amount" ], utxo[ "privkey" ], utxo[ "pubkey" ]
                var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
                psbt.addInput({
                  hash: utxo[ "tx_id" ],
                  index: utxo[ "output_number" ],
                  sequence: 0xfffffffe,
                  witnessUtxo: {
                    script: Buffer.from( '0020' +
                      bitcoinjs.crypto.sha256( Buffer.from( witnessscript, "hex" ) ).toString( "hex" ), "hex" ),
                    value: utxo[ "amount" ]
                  },
                  witnessScript: Buffer.from( witnessscript, "hex" )
                });
                psbt
                  .addOutput({
                    script: embed.output,
                    value: amount_to_burn,
                });
                psbt.signInput( 0, bitcoinjs.ECPair.fromPrivateKey( Buffer.from( utxo[ "privkey" ], "hex" ) ) );

                var getFinalScripts = ( txindex, input, script ) => {
                  // Step 1: Check to make sure the meaningful locking script matches what you expect.
                  var decompiled = bitcoinjs.script.decompile( script )
                  if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_DROP ) {
                    throw new Error( `Can not finalize input #${txindex}` )
                  }

                  // Step 2: Create final scripts
                  var witnessStackClaimBranch = bitcoinjs.payments.p2wsh({
                    redeem: {
                      output: script,
                      input: bitcoinjs.script.compile([
                        input.partialSig[ 0 ].signature,
                        Buffer.from( preimage, "hex" ),
                        Buffer.from( "", "hex" ),
                      ]),
                    }
                  });
                  return {
                    finalScriptWitness: witnessStackToScriptWitness( witnessStackClaimBranch.witness )
                  }
                }
                psbt.finalizeInput( 0, getFinalScripts );
                return psbt.extractTransaction().toHex();
            }
            async function getFeeToBeat( txid_you_spent, fee_you_paid ) {
                var fee_to_beat = 0;
                var mempool = await getData( "https://mempool.space/testnet/api/address/tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0/txs/mempool" );
                JSON.parse( mempool ).forEach( function( tx ) {
                    tx[ "vin" ].forEach( function( input ) {
                        if ( input[ "txid" ] == txid_you_spent && tx[ "fee" ] > fee_you_paid ) {
                            fee_to_beat > tx[ "fee" ];
                        }
                    });
                });
                return fee_to_beat;
            }
            function isValidBitcoinTransaction( rawtx ) {
                try {
                    bitcoinjs.Transaction.fromHex( rawtx );
                    return true;
                } catch( e ) {
                }
                return false;
            }
            function reverseHexString( s ) {
                return s.match(/[a-fA-F0-9]{2}/g).reverse().join('');
            }
            function computeRawPrivkey( node ) {
                return bitcoinjs.ECPair.fromPrivateKey( node.privateKey ).privateKey.toString( "hex" );
            }
            function getPrivkeyHexFromPath( backupwords, path, index ) {
                //standard spacechain path is m/295'/0'/0'/0 so “path” should be 295'/0'/0' and “index” 0
                var seed = bip39.mnemonicToSeedSync( backupwords );
                var node = bip32.fromSeed( seed );
                var path = "m/" + path + "/" + index;
                var root = node;
                var child = root.derivePath( path );
                return computeRawPrivkey( child );
            }
            function getPubkeyHexFromPrivkeyHex( privkey ) {
                var keys = bitcoinjs.ECPair.fromPrivateKey( Buffer.from( privkey, "hex" ) );
                return keys.publicKey.toString( "hex" );
            }
            //end of bitcoin functions
            //spacechain functions
            async function waitThenCreate( address, amount, preimage, privkey, pubkey, timelock, serverPubkey, anchor_address ) {
                //wait for the utxo to be ready
                var utxo_is_ready = await utxoIsReady( address, amount, privkey, pubkey );
                //make the genesis block
                await makeGenesisBlock();
                var spaceblock_hash = sessionStorage[ "spaceblock_hash" ];
                //use it to create an anchor output
                //the anchor output will be created in a transaction whose witness contains
                //a commitment to the spacechain's genesis block AND the preimage needed
                //to settle the lightning invoice, if one was used
                var utxos = await getUTXOsInAddress( address, privkey, pubkey );
                var utxo = utxos[ 0 ];
                //the utxo object is used like this: utxo[ "tx_id" ], utxo[ "output_number" ],
                //utxo[ "amount" ], utxo[ "privkey" ], utxo[ "pubkey" ]
                var pmthash = bitcoinjs.crypto.sha256( Buffer.from( preimage, "hex" ) ).toString( "hex" );
                //add the spaceblock's hash to bitcoin's blockchain
                var rawtx = getRawTxThatMakesAnchorOutputFromSwapAddress( utxo, timelock, serverPubkey, pmthash, anchor_address, spaceblock_hash, preimage );
                var txid = await pushBTCpmt( rawtx );
                return txid;
            }
            async function waitThenMoveAnchor( address, amount, preimage, privkey, pubkey, timelock, serverPubkey, anchor_address ) {
                //wait for the utxo to be ready
                var utxo_is_ready = await utxoIsReady( address, amount, privkey, pubkey );
                //get next block
                var spaceblock = JSON.parse( sessionStorage[ "next_spaceblock" ] );
                var spaceblock_hash = sessionStorage[ "spaceblock_hash" ];
                console.log( "spaceblock_hash:", spaceblock_hash );
                //use it to create an anchor output, but to do that we should try to move the anchor utxo,
                //and to do that we need to find it, and to find it we need the hash of the previous
                //spaceblock
                //get hash of previous spaceblock
                var previous_blockhash = getSpacechainHashes()[ getSpacechainHashes().length - 1 ];
                //get latest anchor txid
                var latest_known_anchor_txid = anchor_utxos_in_my_spacechain[ anchor_utxos_in_my_spacechain.length - 1 ];
                var anchor_tx = await returnLatestAnchorTxidOrThatNewOneMustBeMade( latest_known_anchor_txid );
                if ( !anchor_tx ) {
                    alert( "oh no, something went terribly wrong! Aborting. Please ask a developer for help." );
                    return;
                }
                //check if the anchor utxo is where we expect it to be -- i.e. it should
                //be the first output of that transaction and it should be unspent
                console.log( "anchor txid:", anchor_tx );
                if ( anchor_tx == "make new one" ) {
                    console.log( `oh no, the anchor was stolen!` );
                    var utxos = await getUTXOsInAddress( address, privkey, pubkey );
                    var utxo = utxos[ 0 ];
                    //the utxo object is used like this: utxo[ "tx_id" ], utxo[ "output_number" ],
                    //utxo[ "amount" ], utxo[ "privkey" ], utxo[ "pubkey" ]
                    var pmthash = bitcoinjs.crypto.sha256( Buffer.from( preimage, "hex" ) ).toString( "hex" );
                    //add the spaceblock's hash to bitcoin's blockchain
                    var rawtx = getRawTxThatMakesAnchorOutputFromSwapAddress( utxo, timelock, serverPubkey, pmthash, anchor_address, spaceblock_hash, preimage );
                    var txid = await pushBTCpmt( rawtx );
                    return txid;
                } else {
                    var utxos = await getUTXOsInAddress( address, privkey, pubkey );
                    var utxo = utxos[ 0 ];
                    console.log( preimage );
                    var pmthash = bitcoinjs.crypto.sha256( Buffer.from( preimage, "hex" ) ).toString( "hex" );
                    //add the spaceblock's hash to bitcoin's blockchain
                    console.log( "made it here", 1 );
                    var rawtx = getRawTxThatMovesAnchorOutput( utxo, anchor_tx, timelock, serverPubkey, pmthash, anchor_address, spaceblock_hash, preimage );
                    var txid = await pushBTCpmt( rawtx );
                    return txid;
                }
            }
            async function waitThenBurn( address, amount_to_burn_plus_fee, preimage, privkey, pubkey, timelock, serverPubkey, op_return, amount_to_burn ) {
                console.log( "op_return:", op_return );
                //wait for the utxo to be ready
                var utxo_is_ready = await utxoIsReady( address, amount_to_burn_plus_fee, privkey, pubkey );
                var utxos = await getUTXOsInAddress( address, privkey, pubkey );
                var utxo = utxos[ 0 ];
                var pmthash = bitcoinjs.crypto.sha256( Buffer.from( preimage, "hex" ) ).toString( "hex" );
                //add the op_return to bitcoin's blockchain
                var rawtx = getRawTxThatMakesAnOpReturn( utxo, timelock, serverPubkey, pmthash, op_return, preimage, amount_to_burn );
                var txid = await pushBTCpmt( rawtx );
                return txid;
            }
            async function getBlockAfterTheft( num_of_seconds_to_wait, spaceblock_to_request ) {
                requestBlock( spaceblock_to_request, true );
                var started_waiting_time = Math.floor( Date.now() / 1000 );
                async function isNoteSetYet( note_i_seek ) {
                    return new Promise( function( resolve, reject ) {
                        if ( !note_i_seek ) {
                            var current_time = Math.floor( Date.now() / 1000 );
                            if ( started_waiting_time + num_of_seconds_to_wait < current_time ) {
                                resolve( "time_is_up" );
                            }
                            setTimeout( async function() {
                                var msg = await isNoteSetYet( sessionStorage[ "block_after_theft" ] );
                                resolve( msg );
                            }, 100 );
                        } else {
                            resolve( note_i_seek );
                        }
                    });
                }
                async function getTimeoutData() {
                    var note_i_seek = await isNoteSetYet( sessionStorage[ "block_after_theft" ] );
                    return note_i_seek;
                }
                var returnable = await getTimeoutData();
                return returnable;
            }
            async function requestBlock2( num_of_seconds_to_wait, hash_of_block ) {
                var block_i_seek = "";
                spacechain.every( function( block ) {
                    if ( bitcoinjs.crypto.sha256( block[ 1 ] ).toString( "hex" ) == hash_of_block ) {
                        block_i_seek =  block[ 1 ];
                        return;
                    }
                    return true;
                });
                if ( !block_i_seek ) requestBlock( hash_of_block, false, true );
                var started_waiting_time = Math.floor( Date.now() / 1000 );
                async function isNoteSetYet( note_i_seek ) {
                    return new Promise( function( resolve, reject ) {
                        if ( !note_i_seek ) {
                            block_i_seek = sessionStorage[ "block_being_sought" ];
                            var current_time = Math.floor( Date.now() / 1000 );
                            console.log( block_i_seek );
                            if ( started_waiting_time + num_of_seconds_to_wait < current_time && !block_i_seek ) {
                                resolve( "time_is_up" );
                            }
                            setTimeout( async function() {
                                var msg = await isNoteSetYet( block_i_seek );
                                if ( msg ) {
                                    console.log( "a miner gave it to me!" );
                                }
                                resolve( msg );
                            }, 100 );
                        } else {
                            resolve( note_i_seek );
                        }
                    });
                }
                async function getTimeoutData() {
                    var note_i_seek = await isNoteSetYet( block_i_seek );
                    return note_i_seek;
                }
                var returnable = await getTimeoutData();
                return returnable;
            }

            async function showBlockInExplorer( block, index ) {
                $( '.launch_page' ).style.display = "none";
                $( '.spaceblock_explorer' ).style.display = "block";
                $( '.spaceblocks_loading' ).style.display = "none";
                $( '.spaceblocks' ).innerHTML = ``;
                var anchor_tx = spacechain[ index ][ 2 ];
                var blocksize = textToHex( JSON.stringify( getBlockFromSpacechain( block )[ 0 ] ) ).length / 2;
                var transactions = JSON.parse( getBlockFromSpacechain( block )[ 0 ] );
                var div = document.createElement( "div" );
                div.className = `spaceblock_${index + 1}`;
                if ( index ) {
                    div.innerHTML += `<button class="prev_spaceblock_${index + 1}">Prev</button>`;
                } else {
                    div.innerHTML += `<button class="prev_spaceblock" disabled title="this is the genesis block, there are no previous blocks">Prev</button>`;
                }
                if ( index != getSpacechainHashes().length - 1 ) {
                    div.innerHTML += `<button class="next_spaceblock_${index + 1}">Next</button>`;
                } else {
                    div.innerHTML += `<button class="next_spaceblock" disabled title="this is the last block, consider mining more!">Next</button>`;
                }
                div.innerHTML += `<hr>`;
                div.innerHTML += `<h2>Block ${index + 1}<h2>`;
                div.innerHTML += `<p>Hash: ${block}<p>`;
                div.innerHTML += `<p>Anchor: ${anchor_tx}<p>`;
                div.innerHTML += `<p style="color: red; display: none;" class="noconf_warning">The anchor transaction for this block is not yet confirmed on the bitcoin blockchain. Do not rely on its contents until it is confirmed because another spacechain miner can pay a higher fee to anchor a different block in this one's place.<p>`;                        
                div.innerHTML += `<p>Anchor fee: <span class="anchor_fee">loading...</span><p>`;
                div.innerHTML += `<p>Total size: ${blocksize} bytes<p>`;
                div.innerHTML += `<p>Number of transactions: ${transactions.length - 1}<p>`;
                div.innerHTML += `<p>Average transaction size: ${Math.round( blocksize / transactions.length - 1 )} bytes<p>`;
                div.innerHTML += `<p>Metadata size: ${blocksize - Math.round( blocksize / transactions.length - 1 )} bytes<p>`;
                div.innerHTML += `<h2>Transactions<h2>`;
                transactions.forEach( function( tx, index ) {
                    if ( index == 0 ) return;
                    var pgraph = document.createElement( "p" );
                    pgraph.innerText = `Tx${index}: ${tx}`;
                    div.append( pgraph );
                });
                $( '.spaceblocks' ).append( div );
                if ( index ) {
                    $( `.prev_spaceblock_${index + 1}` ).onclick = function() {
                        showBlockInExplorer( spacechain[ index - 1 ][ 0 ], index - 1 );
                    }
                }
                if ( index != getSpacechainHashes().length - 1 ) {
                    $( `.next_spaceblock_${index + 1}` ).onclick = function() {
                        showBlockInExplorer( spacechain[ index + 1 ][ 0 ], index + 1 );
                    }
                }
                var anchor_fee = await getFeePaidByTx( anchor_tx );
                $( '.anchor_fee' ).innerText = anchor_fee + " sats";
                var txdata = await getData( `https://mempool.space/testnet/api/tx/${anchor_tx}` );
                var confirmed = JSON.parse( txdata )[ "status" ][ "confirmed" ];
                if ( !confirmed ) $( '.noconf_warning' ).style.display = "block";
            }

            function createQR( content ) {
                var dataUriPngImage = document.createElement( "img" ),
                s = QRCode.generatePNG( content, {
                    ecclevel: "M",
                    format: "html",
                    fillcolor: "#FFFFFF",
                    textcolor: "#000000",
                    margin: 4,
                    modulesize: 8,
                });
                dataUriPngImage.src = s;
                dataUriPngImage.className = "qr_code";
                return dataUriPngImage;
            }
            function isValidJson( content ) {
                if ( !content ) return;
                try {  
                    var json = JSON.parse( content );
                } catch ( e ) {
                    return;
                }
                return true;
            }
            function isHex( h ) {
                if ( !h ) return;
                var length = h.length;
                if ( length % 2 ) return;
                try {
                    var a = BigInt( "0x" + h, "hex" );
                } catch( e ) {
                    return;
                }
                var unpadded = a.toString( 16 );
                var padding = [];
                var i; for ( i=0; i<length; i++ ) padding.push( 0 );
                padding = padding.join( "" );
                padding = padding + unpadded.toString();
                padding = padding.slice( -Math.abs( length ) );
                return ( padding === h );
            }
            function copyText( element ) {
                element.select();
                element.setSelectionRange( 0, 99999 );
                navigator.clipboard.writeText( element.value );
                alert( 'copied ' + element.value );
            }
            function getInvoiceAmount( invoice ) {
                var decoded = bolt11.decode( invoice );
                var amount = decoded[ "satoshis" ].toString();
                return Number( amount );
            }
            async function makeGenesisBlock() {
                //create a spaceblock template i.e. an empty array
                var spaceblock = [];
                //pass in an array of user data
                var userdata = [];
                var spacechain_name = $( '.genesis_block_finalized .genesis_block input' ).value;
                var spacechain_msg = $( '.genesis_block_finalized .genesis_block textarea' ).value;
                var json = JSON.stringify( {"spacechain_name": spacechain_name, "spacechain_msg": spacechain_msg} );
                userdata.push( json );
                userdata.forEach( function( data ) {
                    //only let users add strings to the chain
                    if ( typeof( data ) == "string" ) {
                        var possible_spaceblock = Array.from( spaceblock );
                        possible_spaceblock.push( data );
                        var size_in_bytes = textToHex( JSON.stringify( possible_spaceblock ) ).length / 2;
                        if ( size_in_bytes <= 10000000 ) {
                            spaceblock.push( data );
                        }
                    }
                });
                //merkle-ize the spaceblock
                var unresolvedPromises = spaceblock.map( bitcoinjs.crypto.sha256 );
                var leaves = await Promise.all( unresolvedPromises );
                var tree = new MerkleTree( leaves );
                var merkleroot = tree.getRoot().toString( "hex" );
                //get the 32 byte hash of the spaceblock being built upon
                var parent = "0000000000000000000000000000000000000000000000000000000000000000";
                //make the block header
                var header = parent + merkleroot;
                //insert the header into the spaceblock as its first item
                spaceblock.splice( 0, 0, header );
                //get the spaceblock's hash
                var hash = bitcoinjs.crypto.sha256( JSON.stringify( spaceblock ) ).toString( "hex" );
                sessionStorage[ "spaceblock_hash" ] = hash;
                sessionStorage[ "next_spaceblock" ] = JSON.stringify( spaceblock );
            }

            async function getFeePaidByTx( tx ) {
                var data = await getData( `https://mempool.space/testnet/api/tx/${tx}` );
                if ( isValidJson( data ) ) {
                    var fee = JSON.parse( data )[ "fee" ];
                } else {
                    fee = "error";
                }
                return fee;
            }

            async function getNumberOfTxsInvolvingAddress( address ) {
                var data = await getData( `https://mempool.space/testnet/api/address/${address}` );
                var tx_num_1 = JSON.parse( data )[ "chain_stats" ][ "tx_count" ];
                var tx_num_2 = JSON.parse( data )[ "mempool_stats" ][ "tx_count" ];
                //the line below is necessary because mempool.space only returns up to 50 mempool transactions for a given address
                //if a data source other than mempool.space/testnet/ (or mempool.space mainnet) is used, remove the line
                if ( tx_num_2 > 50 ) tx_num_2 = 50;
                return tx_num_1 + tx_num_2;
            }

            async function getNumberOfConfirmedTxsInvolvingAddress( address ) {
                var data = await getData( `https://mempool.space/testnet/api/address/${address}` );
                var tx_num = JSON.parse( data )[ "chain_stats" ][ "tx_count" ];
                return tx_num;
            }

            async function getAllTxsInvolvingAddress( address ) {
                var tx_num = await getNumberOfTxsInvolvingAddress( address );
                var txs = [];
                var last_seen = "";
                var i; for ( i=0; i<tx_num; i = i + 25 ) {
                    if ( last_seen ) {
                        var url = `https://mempool.space/testnet/api/address/${address}/txs/${last_seen}`;
                    } else {
                        var url = `https://mempool.space/testnet/api/address/${address}/txs`;
                    }
                    var info = await getData( url );
                    last_seen = JSON.parse( info )[ JSON.parse( info ).length - 1 ][ "txid" ];
                    JSON.parse( info ).forEach( function( item ) {
                        txs.push( item )
                    });
                    if ( $( '.spaceblocks_loading_percent' ) ) {
                        $( '.spaceblocks_loading_percent' ).innerText = Math.floor( ( txs.length / tx_num ) * 10000 ) / 100;
                    }
                }
                return txs;
            }

            async function getAllConfirmedTxsInvolvingAddress( address ) {
                var tx_num = await getNumberOfConfirmedTxsInvolvingAddress( address );
                var txs = [];
                var last_seen = "";
                var i; for ( i=0; i<tx_num; i = i + 25 ) {
                    if ( last_seen ) {
                        var url = `https://mempool.space/testnet/api/address/${address}/txs/chain/${last_seen}`;
                    } else {
                        var url = `https://mempool.space/testnet/api/address/${address}/txs/chain`;
                    }
                    var info = await getData( url );
                    last_seen = JSON.parse( info )[ JSON.parse( info ).length - 1 ][ "txid" ];
                    JSON.parse( info ).forEach( function( item ) {
                        txs.push( item )
                    });
                    if ( $( '.spaceblocks_loading_percent' ) ) {
                        $( '.spaceblocks_loading_percent' ).innerText = Math.floor( ( txs.length / tx_num ) * 10000 ) / 100;
                    }
                }
                return txs;
            }

            async function anchorWasStolen( anchor_tx ) {
                //if the utxo list for this address contains at least one utxo with the right txid, output number, and value, mark the anchor tx as unspent
                var this_anchor_is_unspent = false;
                var utxos = await getData( "https://mempool.space/testnet/api/address/tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0/utxo" );
                JSON.parse( utxos ).every( function( utxo ) {
                    if (
                        utxo[ "txid" ] == anchor_tx &&
                        utxo[ "vout" ] == 0 &&
                        utxo[ "value" ] == 546
                    ) {
                        this_anchor_is_unspent = true;
                        return false;
                    }
                    return true;
                });
                if ( this_anchor_is_unspent ) return;
                //otherwise check if it has a valid successor and if so return false
                var anchor_was_stolen = true;
                var candidate_anchors = await getAllTxsInvolvingAddress( "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0" );
                candidate_anchors.forEach( function( candidate ) {
                    if (
                        candidate[ "vin" ][ 0 ][ "txid" ] == anchor_tx &&
                        candidate[ "vout" ][ 0 ][ "scriptpubkey_address" ] == "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0" &&
                        candidate[ "vout" ][ 0 ][ "value" ] == 546
                    ) {
                        anchor_was_stolen = false;
                    }
                });
                return anchor_was_stolen;
            }

            async function getNewAnchorTx( old_anchor_tx, candidate_anchors ) {
                var new_anchor_tx = "";
                if ( !candidate_anchors ) {
                    var candidate_anchors = await getAllTxsInvolvingAddress( "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0" );
                }
                candidate_anchors.forEach( function( candidate ) {
                    if (
                        candidate[ "vin" ][ 0 ][ "txid" ] == old_anchor_tx &&
                        candidate[ "vout" ][ 0 ][ "scriptpubkey_address" ] == "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0" &&
                        candidate[ "vout" ][ 0 ][ "value" ] == 546
                    ) {
                        new_anchor_tx = candidate[ "txid" ];
                    }
                });
                return new_anchor_tx;
            }

            async function returnAnchorTxidsTilTheftOrCurrentBlockheight( chain ) {
                var latest_known_anchor_txid = chain[ chain.length - 1 ];
                var anchor_was_stolen = await anchorWasStolen( latest_known_anchor_txid );
                if ( anchor_was_stolen ) return chain;
                var new_anchor = await getNewAnchorTx( latest_known_anchor_txid );
                if ( !new_anchor ) return chain;
                chain.push( new_anchor );
                return returnAnchorTxidsTilTheftOrCurrentBlockheight( chain );
            }

            function getBlockheightByAnchorTxid( anchor_txid ) {
                var blockheight = -1;
                spacechain.every( function( block, index ) {
                    if ( block[ 2 ] == anchor_txid ) {
                        blockheight = index;
                        return;
                    }
                    return true;
                });
                return blockheight;
            }

            async function returnLatestAnchorTxidOrThatNewOneMustBeMade( latest_known_anchor_txid ) {
                var anchor_was_stolen = await anchorWasStolen( latest_known_anchor_txid );
                var recovery_anchor = "";
                if ( anchor_was_stolen ) {
                    //check if the chain was recovered after the theft
                    sessionStorage[ "block_after_theft" ] = "";
                    var chain_before_theft = await traceHistory( "", null, [], latest_known_anchor_txid );
                    var num_of_known_spaceblocks = chain_before_theft.length;
                    var block_after_theft = await getBlockAfterTheft( 15, num_of_known_spaceblocks + 1 );
                    if ( block_after_theft == "fork_alert" ) {
                        //resolve the fork and set block_after_theft equal to the real block (json-stingified)
                        var hash_of_fork_block_1 = bitcoinjs.crypto.sha256( sessionStorage[ "potential_fork_block_1" ] ).toString( "hex" );
                        var hash_of_fork_block_2 = bitcoinjs.crypto.sha256( sessionStorage[ "potential_fork_block_2" ] ).toString( "hex" );
                        var block_after_theft = await resolveFork( hash_of_fork_block_1, hash_of_fork_block_2 );
                    }
                    if ( block_after_theft != "time_is_up" ) {
                        //if there is no fork related to the theft and there is a successor block
                        //then proceed assuming that the new anchorpoint cannot be invalid
                        var block_hash = bitcoinjs.crypto.sha256( block_after_theft ).toString( "hex" );
                        sessionStorage[ "block_after_theft" ] = "";
                        //check if the block was anchored into bitcoin
                        var candidate_anchors = await getAllTxsInvolvingAddress( "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0" );
                        recovery_anchor = findAnchorAmongCandidates( candidate_anchors, block_hash );
                    }
                }
                if ( anchor_was_stolen && !recovery_anchor ) {return "make new one";}
                if ( recovery_anchor ) {
                    latest_known_anchor_txid = recovery_anchor;
                }
                var current_anchor = latest_known_anchor_txid;
                if ( !anchor_utxos_in_my_spacechain.includes( current_anchor ) ) {
                    anchor_utxos_in_my_spacechain.push( current_anchor );
                    localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
                }
                if ( !candidate_anchors ) {
                    var candidate_anchors = null;
                }
                var new_anchor = await getNewAnchorTx( latest_known_anchor_txid, candidate_anchors );
                if ( !new_anchor ) return current_anchor;
                var latest_anchor = await returnLatestAnchorTxidOrThatNewOneMustBeMade( new_anchor );
                return latest_anchor;
            }

            function findAnchorAmongCandidates( candidate_anchors, spaceblock_hash ) {
                var i; for ( i=0; i<candidate_anchors.length; i++ ) {
                    var script_is_right = false;
                    var value_is_right = false;
                    var hash_is_right = false;
                    var drop_is_right = false;
                    if ( candidate_anchors[ i ][ "vout" ][ 0 ][ "scriptpubkey_address" ] == "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0" ) {
                        script_is_right = true;
                    }
                    if ( candidate_anchors[ i ][ "vout" ][ 0 ][ "value" ] == 546 ) {
                        value_is_right = true;
                    }
                    if ( candidate_anchors[ i ][ "vin" ][ 0 ][ "witness" ][ candidate_anchors[ i ][ "vin" ][ 0 ][ "witness" ].length - 2 ] == spaceblock_hash ) {
                        hash_is_right = true;
                    }
                    if ( candidate_anchors[ i ][ "vin" ][ 0 ][ "witness" ][ candidate_anchors[ i ][ "vin" ][ 0 ][ "witness" ].length - 1 ].startsWith( "75" ) ) {
                        drop_is_right = true;
                    }
                    if ( script_is_right && value_is_right && hash_is_right && drop_is_right ) {
                        return candidate_anchors[ i ][ "txid" ];
                    }
                }
            }

            async function getSpaceblockHashFromAnchorTxId( anchor_tx ) {
                var txdata = await getData( "https://mempool.space/testnet/api/tx/" + anchor_tx );
                txdata = JSON.parse( txdata );
                var spaceblock_hash = txdata[ "vin" ][ 0 ][ "witness" ][ txdata[ "vin" ][ 0 ][ "witness" ].length - 2 ];
                return spaceblock_hash;
            }

            async function generateBlock( userdata, parent ) {
                //create a spaceblock template i.e. an empty array
                var spaceblock = [];
                //pass in the user data
                userdata.forEach( function( data ) {
                    //only let users add strings to the chain
                    if ( typeof( data ) == "string" ) {
                        var possible_spaceblock = Array.from( spaceblock );
                        possible_spaceblock.push( data );
                        var size_in_bytes = textToHex( JSON.stringify( possible_spaceblock ) ).length / 2;
                        if ( size_in_bytes <= 10000000 ) {
                            spaceblock.push( data );
                        }
                    }
                });
                //merkle-ize the spaceblock
                var unresolvedPromises = spaceblock.map( bitcoinjs.crypto.sha256 );
                var leaves = await Promise.all( unresolvedPromises );
                var tree = new MerkleTree( leaves );
                var merkleroot = tree.getRoot().toString( "hex" );
                //make the block header
                var header = parent + merkleroot;
                //insert the header into the spaceblock as its first item
                spaceblock.splice( 0, 0, header );
                //get the spaceblock's hash
                var hash = bitcoinjs.crypto.sha256( JSON.stringify( spaceblock ) ).toString( "hex" );
                return [ hash, spaceblock ];
            }
            async function isCandidateBlock( block ) {
                if ( !isValidJson( block ) ) return;
                block = JSON.parse( block );
                if ( !block[ 0 ] || !block[ 1 ] ) return;
                if ( typeof( block[ 0 ] ) != "string" || block[ 0 ].length != 128 ) return;
                var size_in_bytes = textToHex( JSON.stringify( block ) ).length / 2;
                if ( size_in_bytes > 10000000 ) return;
                var spaceblock = [];
                var all_items_are_strings = true;
                block.forEach( function( item, index ) {
                    if ( typeof( item ) != "string" ) all_items_are_strings = false;
                    if ( !index ) return;
                    spaceblock.push( item );
                });
                if ( !all_items_are_strings ) return;
                //recreate the spaceblock including its merkle root and check if it matches the one passed in
                var unresolvedPromises = spaceblock.map( bitcoinjs.crypto.sha256 );
                var leaves = await Promise.all( unresolvedPromises );
                var tree = new MerkleTree( leaves );
                var merkleroot = tree.getRoot().toString( "hex" );
                //get the 32 byte hash of the spaceblock being built upon
                var parent = block[ 0 ].substring( 0, 64 );
                //make the block header
                var header = parent + merkleroot;
                //insert the header into the spaceblock as its first item
                spaceblock.splice( 0, 0, header );
                //get the spaceblock's hash
                var actual_spaceblock_hash = bitcoinjs.crypto.sha256( JSON.stringify( spaceblock ) ).toString( "hex" );
                var claimed_spaceblock_hash = bitcoinjs.crypto.sha256( JSON.stringify( block ) ).toString( "hex" );
                if ( actual_spaceblock_hash != claimed_spaceblock_hash ) return;
                return true;
            }
            function getSpacechainHashes() {
                var hashes = [];
                spacechain.forEach( function( item ) {
                    hashes.push( item[ 0 ] );
                });
                return hashes;
            }

            function getBlockFromSpacechain( hash ) {
                var block = "";
                var index_of_value = -1;
                spacechain.every( function( hash_block_pair, index ) {
                    if ( hash_block_pair[ 0 ] == hash ) {
                        block = hash_block_pair[ 1 ];
                        index_of_value = index;
                        return;
                    }
                    return true;
                 });
                if ( index_of_value >= 0 ) {
                    return [block, index_of_value]
                } else {
                    return;
                }
            }

            async function findWhichTxAppearedFirst( tx1, tx2 ) {
                console.log( "here are the two transaction ids:", tx1, tx2 );
                if ( tx1 == tx2 ) return tx1;
                var tx_that_appeared_first = "";
                var block_of_tx1 = await getData( `https://mempool.space/testnet/api/tx/${tx1}` );
                block_of_tx1 = JSON.parse( block_of_tx1 )[ "status" ][ "block_height" ];
                var block_of_tx2 = await getData( `https://mempool.space/testnet/api/tx/${tx2}` );
                block_of_tx2 = JSON.parse( block_of_tx2 )[ "status" ][ "block_height" ];
                if ( block_of_tx1 < block_of_tx2 ) return tx1;
                if ( block_of_tx2 < block_of_tx1 ) return tx2;
                //get all txs in the block and check if tx1 or tx2 appears first
                block = await getData( `https://mempool.space/testnet/api/block-height/${block_of_tx1}` );
                var block_info = await getData( `https://mempool.space/testnet/api/block/${block}` );
                tx_count = JSON.parse( block_info )[ "tx_count" ];
                var num_of_pages = Math.ceil( tx_count / 25 );
                var i; for ( i=0; i<num_of_pages; i++ ) {
                    var num = i*25;
                    var url = `https://mempool.space/testnet/api/block/${block}/txs/${String( num )}`;
                    var txs = await getData( url );
                    txs = JSON.parse( txs );
                    txs.every( function( tx ) {
                        if ( tx[ "txid" ] == tx1 ) {
                            tx_that_appeared_first = tx1;
                            return;
                        }
                        if ( tx[ "txid" ] == tx2 ) {
                            tx_that_appeared_first = tx2;
                            return;
                        }
                        return true;
                    });
                }
                return tx_that_appeared_first;
            }

            function shuffleArray( array ) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor( Math.random() * ( i + 1 ) );
                    [ array[ i ], array[ j ] ] = [ array[ j ], array[ i ] ];
                }
            }
            function findIndexOfNonIdentity( arr1, arr2 ) {
                var i; for ( i=0; i<arr1.length; i++ ) {
                    if ( arr1[ i ] != arr2[ i ] ) return i;
                    if ( arr1[ i ] == arr1.length - 1) return i + 1;
                }
            }
            async function getBlockhashByAnchorTxid( anchor_txid ) {
                var tx = await getData( `https://mempool.space/testnet/api/tx/${anchor_txid}` );
                if ( tx == "Transaction not found" ) return "bad_txid";
                tx = JSON.parse( tx );
                if ( !tx[ "vin" ] || !tx[ "vin" ][ 0 ] || !tx[ "vin" ][ 0 ][ "witness" ] || tx[ "vin" ][ 0 ][ "witness" ].length - 2 < 0 ) return "bad_txid";
                if ( tx[ "vin" ][ 0 ][ "witness" ][ tx[ "vin" ][ 0 ][ "witness" ].length - 2 ].length != 64 ) return "bad_txid";
                if ( tx[ "vout" ][ 0 ][ "scriptpubkey_address" ] != "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0" ) return "bad_txid";
                if ( tx[ "vout" ][ 0 ][ "value" ] != 546 ) return "bad_txid";
                return tx[ "vin" ][ 0 ][ "witness" ][ tx[ "vin" ][ 0 ][ "witness" ].length - 2 ];
            }
            async function traceHistory( candidate_anchors, blockhash, chain = [], anchor ) {
                if ( !candidate_anchors ) {
                    candidate_anchors = await getAllTxsInvolvingAddress( "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0" );
                }
                if ( !anchor ) {
                    var anchor_txid = findAnchorAmongCandidates( candidate_anchors, blockhash );                    
                } else {
                    var anchor_txid = anchor;
                    blockhash = await getBlockhashByAnchorTxid( anchor_txid );
                    if ( blockhash == "bad_txid" ) return "bad chain";
                }
                //console.log( "blockhash:", blockhash );
                //console.log( "anchor_txid:", anchor_txid );
                if ( !anchor_txid ) return "bad chain";
                chain.splice( 0, 0, anchor_txid );
                sessionStorage[ "block_being_sought" ] = "";
                var getting_my_block = await requestBlock2( 5, blockhash );
                //console.log( "run this:", `var block = await requestBlock2( 5, "${blockhash}" );` );
                if ( getting_my_block == "time_is_up" ) {console.log( "here is the block:", block );return "bad chain";}
                var parent_of_block = JSON.parse( getting_my_block )[ 0 ].substring( 0, 64 );
                if ( parent_of_block == "0000000000000000000000000000000000000000000000000000000000000000" ) return chain;
                return traceHistory( candidate_anchors, parent_of_block, chain );
            }

            async function resolveFork( block_1_hash, block_2_hash ) {
                if ( block_1_hash == block_2_hash ) return block_1_hash;
                var candidate_anchors = await getAllTxsInvolvingAddress( "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0" );
                //trace each block's history to the beginning of its chain
                var chain_1 = await traceHistory( candidate_anchors, block_1_hash );
                var chain_2 = await traceHistory( candidate_anchors, block_2_hash );
                //for each anchor_tx in chain_1, check if it anchored the spacechain
                //before any thefts occurred (using chain_til_theft_or_blockheight)
                //then run the anchor after that through returnAnchorTxidsTilTheftOrCurrentBlockheight()
                //and add the result to chain_til_theft_or_blockheight (or rather a copy of it)
                //then continue checking if subsequent anchor_tx's anchored the spacechain
                //before any thefts occurred, etc.
                //if an anchorpoint comes immediately *after* a theft then consider it
                //a valid anchorpoint
                var unstolen_chain_1_anchors = chain_til_theft_or_blockheight;
                var index_where_theft_happens_if_any = findIndexOfNonIdentity( chain_1, unstolen_chain_1_anchors );
                if ( index_where_theft_happens_if_any != chain_1.length ) {
                    var more_anchors = await returnAnchorTxidsTilTheftOrCurrentBlockheight( chain_1.slice( index_where_theft_happens_if_any ) );
                    more_anchors.every( async function( anchor ) {
                        //if any anchor from this point appears in bitcoin's blockchain before
                        //the last unstolen anchor, ignore chain_1
                        var tx_that_appeared_first = await findWhichTxAppearedFirst( anchor, unstolen_chain_1_anchors[ unstolen_chain_1_anchors.length - 1 ] );
                        if ( tx_that_appeared_first == anchor ) {
                            //if miners gave me bad data about chain_1 and chain_2, I will
                            //mark chain_1 as bad and assume chain_2 is good, because
                            //if miners gave me bad data about chain_2 as well, I will
                            //learn that later when I learn of the consensus fork from good
                            //miners and then try to resolve the fork
                            chain_1 = "bad_chain";
                            return;
                        }
                        unstolen_chain_1_anchors.push( anchor );
                        return true;
                    });
                }
                if ( chain_1 == "bad_chain" ) {
                    if ( chain_2 == "bad chain" ) {
                        alert( "something went terribly wrong while resolving a fork. Refreshing the webpage and resyncing the chain. If this keeps happening, ask a developer for help." );
                        localStorage.clear();
                        sessionStorage.clear();
                        window.location.reload();
                        await waitSomeSeconds( 600 );
                        return;
                    }
                    anchor_utxos_in_my_spacechain = chain_2;
                    localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
                    spacechain.every( function( block, index ) {
                        if ( block[ 2 ] != anchor_utxos_in_my_spacechain[ index ] ) {
                            spacechain.length = index;
                            if ( $_GET[ "wallet_id" ] ) {
                                adjustUtxoSet( false, $_GET[ "wallet_id" ], index );
                            }
                            return;
                        }
                        return true;
                    });
                    localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                    syncChain();
                    return block_2_hash;
                }
                var unstolen_chain_2_anchors = chain_til_theft_or_blockheight;
                var index_where_theft_happens_if_any = findIndexOfNonIdentity( chain_2, unstolen_chain_2_anchors );
                if ( index_where_theft_happens_if_any != chain_2.length ) {
                    sessionStorage[ "chain_1" ] = JSON.stringify( chain_1 );
                    var more_anchors = await returnAnchorTxidsTilTheftOrCurrentBlockheight( chain_2.slice( index_where_theft_happens_if_any ) );
                    chain_1 = JSON.parse( sessionStorage[ "chain_1" ] );
                    more_anchors.every( async function( anchor ) {
                        //if any anchor from this point appears in bitcoin's blockchain before
                        //the last unstolen anchor, ignore chain_2
                        var tx_that_appeared_first = await findWhichTxAppearedFirst( anchor, unstolen_chain_2_anchors[ unstolen_chain_2_anchors.length - 1 ] );
                        if ( tx_that_appeared_first == anchor ) {
                            chain_2 = "bad_chain";
                            return;
                        }
                        unstolen_chain_2_anchors.push( anchor );
                        return true;
                    });
                }
                if ( chain_2 == "bad_chain" ) {
                    if ( chain_1 == "bad chain" ) {
                        alert( "something went terribly wrong while resolving a fork. Refreshing the webpage and resyncing the chain. If this keeps happening, ask a developer for help." );
                        localStorage.clear();
                        sessionStorage.clear();
                        window.location.reload();
                        await waitSomeSeconds( 600 );
                        return;
                    }
                    anchor_utxos_in_my_spacechain = chain_1;
                    localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
                    spacechain.every( function( block, index ) {
                        if ( block[ 2 ] != anchor_utxos_in_my_spacechain[ index ] ) {
                            spacechain.length = index;
                            if ( $_GET[ "wallet_id" ] ) {
                                adjustUtxoSet( false, $_GET[ "wallet_id" ], index );
                            }
                            return;
                        }
                        return true;
                    });
                    localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                    syncChain();
                    return block_1_hash;
                }
                //if neither chain is bad, find where the two chains deviate
                var deviation_point = findIndexOfNonIdentity( chain_1, chain_2 );
                //if the chains are the same, return chain 1
                if ( deviation_point != 0 && !deviation_point ) return block_1_hash;
                //if the chains deviate ab initio, go with whichever one's first block matches yours
                if ( deviation_point == 0 ) {
                    if ( chain_1[ 0 ] == anchor_utxos_in_my_spacechain[ 0 ] ) {
                        anchor_utxos_in_my_spacechain = chain_1;
                        localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
                        spacechain.every( function( block, index ) {
                            if ( block[ 2 ] != anchor_utxos_in_my_spacechain[ index ] ) {
                                if ( $_GET[ "wallet_id" ] ) {
                                    adjustUtxoSet( false, $_GET[ "wallet_id" ], index );
                                }
                                return;
                            }
                            return true;
                        });
                        localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                        syncChain();
                        return block_1_hash;
                    }
                    if ( chain_2[ 0 ] == anchor_utxos_in_my_spacechain[ 0 ] ) {
                        anchor_utxos_in_my_spacechain = chain_2;
                        localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
                        spacechain.every( function( block, index ) {
                            if ( block[ 2 ] != anchor_utxos_in_my_spacechain[ index ] ) {
                                spacechain.length = index;
                                if ( $_GET[ "wallet_id" ] ) {
                                    adjustUtxoSet( false, $_GET[ "wallet_id" ], index );
                                }
                                return;
                            }
                            return true;
                        });
                        localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                        syncChain();
                        return block_2_hash;
                    }
                }
                //if the deviation point came later, go with the longer chain if possible
                if ( chain_1.length > chain_2.length ) {
                    anchor_utxos_in_my_spacechain = chain_1;
                    localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
                    spacechain.every( function( block, index ) {
                        if ( block[ 2 ] != anchor_utxos_in_my_spacechain[ index ] ) {
                            spacechain.length = index;
                            if ( $_GET[ "wallet_id" ] ) {
                                adjustUtxoSet( false, $_GET[ "wallet_id" ], index );
                            }
                            return;
                        }
                        return true;
                    });
                    localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                    syncChain();
                    return block_1_hash;
                }
                if ( chain_2.length > chain_1.length ) {
                    anchor_utxos_in_my_spacechain = chain_2;
                    localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
                    spacechain.every( function( block, index ) {
                        if ( block[ 2 ] != anchor_utxos_in_my_spacechain[ index ] ) {
                            spacechain.length = index;
                            if ( $_GET[ "wallet_id" ] ) {
                                adjustUtxoSet( false, $_GET[ "wallet_id" ], index );
                            }
                            return;
                        }
                        return true;
                    });
                    localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                    syncChain();
                    return block_2_hash;
                }
                //otherwise get the anchor txid of both at the point of depature
                //and go with whichever chain appeared in bitcoin's blockchain first
                anchor_txid_of_chain_1 = chain_1[ deviation_point ];
                anchor_txid_of_chain_2 = chain_2[ deviation_point ];
                correct_chain_txid = await findWhichTxAppearedFirst( anchor_txid_of_chain_1, anchor_txid_of_chain_2 );
                if ( correct_chain_txid == anchor_txid_of_chain_1 ) {
                    anchor_utxos_in_my_spacechain = chain_1;
                    localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
                    spacechain.every( function( block, index ) {
                        if ( block[ 2 ] != anchor_utxos_in_my_spacechain[ index ] ) {
                            spacechain.length = index;
                            if ( $_GET[ "wallet_id" ] ) {
                                adjustUtxoSet( false, $_GET[ "wallet_id" ], index );
                            }
                            return;
                        }
                        return true;
                    });
                    localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                    syncChain();
                    return block_1_hash;
                }
                anchor_utxos_in_my_spacechain = chain_2;
                localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
                spacechain.every( function( block, index ) {
                    if ( block[ 2 ] != anchor_utxos_in_my_spacechain[ index ] ) {
                        spacechain.length = index;
                        if ( $_GET[ "wallet_id" ] ) {
                            adjustUtxoSet( false, $_GET[ "wallet_id" ], index );
                        }
                        return;
                    }
                    return true;
                });
                localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                syncChain();
                return block_2_hash;
            }
            function isLikelySpaceSig( sig ) {
                var sigstuff = sig.split( "-" );
                if ( sigstuff.length != 3 ) return;
                if ( !isHex( sigstuff[ 0 ] ) && sigstuff[ 0 ] != "" ) return;
                return true;
            }
            async function unlockingScriptIsValid( stack, tx ) {
                if ( typeof( stack ) != "object" ) return;
                if ( !stack[ 0 ] ) return;
                if ( stack.length > 1000 ) return;
                var script = stack[ stack.length - 1 ];
                if ( !isHex( script ) ) return;
                if ( !isValidJson( hexToText( script ) ) ) return;
                script = JSON.parse( hexToText( script ) );
                stack = Array.from( stack );
                stack.splice( stack.length - 1, 1 );
                if ( !script[ 0 ] && stack.length == 1 && stack[ 0 ] == "01" ) return true;
                if ( !script[ 0 ] ) return;
                //console.log( 6 - script.length, script[ 0 ] );
                if ( script[ 0 ] == "OP_DUP" ) {
                    stack.push( stack[ stack.length - 1 ] );
                    script.splice( 0, 1 );
                    var locking_script_hex = textToHex( JSON.stringify( script ) );
                    stack.push( locking_script_hex );
                    return unlockingScriptIsValid( stack, tx );
                }
                if ( script[ 0 ] == "OP_HASH160" ) {
                    var item_to_hash = stack[ stack.length - 1 ];
                    if ( !isHex( item_to_hash ) ) return;
                    var hash = bitcoinjs.crypto.hash160( hexToBytes( item_to_hash ) ).toString( "hex" );
                    stack.splice( stack.length - 1, 1, hash );
                    script.splice( 0, 1 );
                    var locking_script_hex = textToHex( JSON.stringify( script ) );
                    stack.push( locking_script_hex );
                    return unlockingScriptIsValid( stack, tx );
                }
                if ( isHex( script[ 0 ] ) || isLikelySpaceSig( script[ 0 ] ) ) {
                    stack.push( script[ 0 ] );
                    script.splice( 0, 1 );
                    var locking_script_hex = textToHex( JSON.stringify( script ) );
                    stack.push( locking_script_hex );
                    return unlockingScriptIsValid( stack, tx );
                }
                if ( script[ 0 ] == "OP_EQUALVERIFY" ) {
                    if ( stack[ stack.length - 1 ] != stack[ stack.length - 2 ] ) return;
                    stack.splice( stack.length - 2, 2 );
                    script.splice( 0, 1 );
                    var locking_script_hex = textToHex( JSON.stringify( script ) );
                    stack.push( locking_script_hex );
                    return unlockingScriptIsValid( stack, tx );
                }
                if ( script[ 0 ] == "OP_CHECKSIG" ) {
                    var sig_is_good = false;
                    if ( !stack[ stack.length - 2 ] ) return;
                    if ( !isLikelySpaceSig( stack[ stack.length - 2 ] ) ) return;
                    var sigstuff = stack[ stack.length - 2 ].split( "-" );
                    var sighash_prep = JSON.parse( JSON.stringify( tx ) );
                    if ( sigstuff[ 1 ] != "[*]" ) {
                        if ( !isValidJson( sigstuff[ 1 ] ) ) return;
                        var input_list = JSON.parse( sigstuff[ 1 ] );
                        var all_numbers = true;
                        input_list.every( function( item ) {
                            if ( typeof( item ) != "number" || String( item ).includes( "." ) ) {all_numbers = false; return;}
                            return true;
                        });
                        if ( !all_numbers ) return;
                        var highest_num = 0;
                        input_list.forEach( function( item ) {
                            if ( item > highest_num ) highest_num = item;
                        });
                        if ( highest_num > sighash_prep[ "inputs" ].length - 1 ) return;
                        sighash_prep[ "inputs" ].forEach( function( input, index ) {
                            if ( !input_list.includes( index ) ) sighash_prep[ "inputs" ].splice( index, 1 );
                        });
                    }
                    if ( sigstuff[ 2 ] != "[*]" ) {
                        if ( !isValidJson( sigstuff[ 2 ] ) ) return;
                        var output_list = JSON.parse( sigstuff[ 2 ] );
                        var all_numbers = true;
                        output_list.every( function( item ) {
                            if ( typeof( item ) != "number" || String( item ).includes( "." ) ) {all_numbers = false; return;}
                            return true;
                        });
                        if ( !all_numbers ) return;
                        highest_num = 0;
                        output_list.forEach( function( item ) {
                            if ( item > highest_num ) highest_num = item;
                        });
                        if ( highest_num > sighash_prep[ "outputs" ].length - 1 ) return;
                        sighash_prep[ "outputs" ].forEach( function( output, index ) {
                            if ( !output_list.includes( index ) ) sighash_prep[ "outputs" ].splice( index, 1 );
                        });
                    }
                    sighash_prep[ "inputs" ].forEach( function( input ) {delete input[ "redeem_script" ];});
                    var sighash = bitcoinjs.crypto.sha256( JSON.stringify( sighash_prep ) );
                    var keys = bitcoinjs.ECPair.fromPublicKey( Buffer.from( stack[ stack.length - 1 ], "hex" ) );
                    sig_is_good = keys.verify( sighash, Buffer.from( sigstuff[ 0 ], "hex" ) );
                    stack.splice( stack.length - 2, 2 );
                    if ( sig_is_good ) {
                        stack.push( "01" );
                    } else {
                        if ( sigstuff[ 0 ] ) return;
                        stack.push( "00" );
                    }
                    script.splice( 0, 1 );
                    var locking_script_hex = textToHex( JSON.stringify( script ) );
                    stack.push( locking_script_hex );
                    return unlockingScriptIsValid( stack, tx );
                }
            }
            function getSpacechainTxByTxid( txid ) {
                if ( txid.split( ":" ).length != 2 ) return;
                if ( isNaN( txid.split( ":" )[ 0 ] ) || isNaN( txid.split( ":" )[ 1 ] ) ) return;
                var block = Number( txid.split( ":" )[ 0 ] - 1 );
                var txnum = Number( txid.split( ":" )[ 1 ] );
                if ( sessionStorage[ "mining" ] ) {
                    //if you are mining, search for the tx in the current in-progress block
                    if ( getSpacechainHashes().length + 1 == block + 1 ) {
                        var userdata = JSON.parse( sessionStorage[ "userdata" ] );
                        if ( userdata.length < txnum ) return;
                        return userdata[ txnum ];
                    }
                } else {
                    if ( getSpacechainHashes().length < block + 1 ) return;
                }
                var tx_list = JSON.parse( spacechain[ block ][ 1 ] );
                if ( tx_list.length - 1 < txnum ) return;
                var tx = JSON.parse( spacechain[ block ][ 1 ] )[ txnum + 1 ];
                return tx;
            }
            function thisTransactionFromMyUtxoSetOrItsParentsSpentBurnUtxo( tx_to_investigate, txid_of_burn_utxo, output_number ) {
                var it_spent_it = false;
                if ( !Object.keys( tx_to_investigate ).includes( "inputs" ) ) return false;
                tx_to_investigate[ "inputs" ].every( function( input ) {
                    if ( Object.keys( input ).length == 4 && input[ "burntx" ] == txid_of_burn_utxo && input[ "output_index" ] == output_number ) {it_spent_it = true;return;}
                    if ( Object.keys( input ).length == 5 && thisTransactionFromMyUtxoSetOrItsParentsSpentBurnUtxo( JSON.parse( getSpacechainTxByTxid( input[ "blocknum" ] + ":" + input[ "tx_index" ] ) ), txid_of_burn_utxo, output_number ) ) {it_spent_it = true;return;}
                    return true;
                });
                return it_spent_it;
            }
            async function isCoinbaseCandidate( tx, wallet_identifier ) {
                var transaction = tx;
                if ( !isValidJson( transaction ) ) return;
                transaction = JSON.parse( transaction );
                if ( Object.keys( transaction ).length != 4 ) return;
                if ( !Object.keys( transaction ).includes( "wallet" ) ) return;
                if ( !Object.keys( transaction ).includes( "outputs" ) ) return;
                if ( !Object.keys( transaction ).includes( "timelock" ) ) return;
                if ( !Object.keys( transaction ).includes( "inputs" ) ) return;
                if ( transaction[ "wallet" ] != wallet_identifier ) return;
                if ( !Array.isArray( transaction[ "outputs" ] ) ) return;
                if ( !Array.isArray( transaction[ "inputs" ] ) ) return;
                var all_outputs_are_valid = true;
                transaction[ "outputs" ].every( function( output ) {
                    if ( Object.keys( output ).length != 2 ) {all_outputs_are_valid = false;return;}
                    if ( !Object.keys( output ).includes( "scripthash" ) ) {all_outputs_are_valid = false;return;}
                    if ( !Object.keys( output ).includes( "value" ) ) {all_outputs_are_valid = false;return;}
                    if ( typeof( output[ "value" ] ) != "number" || String( output[ "value" ] ).includes( "." ) ) {all_outputs_are_valid = false;return;}
                    return true;
                });
                if ( !all_outputs_are_valid ) return;
                if ( !transaction[ "inputs" ].length ) return true;
            }
            async function transactionIsValidWalletTx( tx, i_am_mining_this_tx, wallet_identifier, blocknum, txnum, do_not_add_to_utxo_set ) {
                if ( !localStorage[ `utxo_set_for_${wallet_identifier}` ] ) {
                    var utxo_set = [];
                    localStorage[ `utxo_set_for_${wallet_identifier}` ] = JSON.stringify( utxo_set );
                } else {
                    var utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                }
                var transaction = tx;
                if ( !isValidJson( transaction ) ) return;
                transaction = JSON.parse( transaction );
                if ( Object.keys( transaction ).length != 4 ) return;
                if ( !Object.keys( transaction ).includes( "wallet" ) ) return;
                if ( !Object.keys( transaction ).includes( "outputs" ) ) return;
                if ( !Object.keys( transaction ).includes( "timelock" ) ) return;
                if ( !Object.keys( transaction ).includes( "inputs" ) ) return;
                if ( transaction[ "wallet" ] != wallet_identifier ) return;
                if ( !Array.isArray( transaction[ "outputs" ] ) ) return;
                if ( !Array.isArray( transaction[ "inputs" ] ) ) return;
                var all_outputs_are_valid = true;
                var i; for ( i=0; i<transaction[ "outputs" ].length; i++ ) {
                    var output = transaction[ "outputs" ][ i ];
                    if ( Object.keys( output ).length != 2 ) {all_outputs_are_valid = false;break;}
                    if ( !Object.keys( output ).includes( "scripthash" ) ) {all_outputs_are_valid = false;break;}
                    //disallow sending money to the same address twice
                    if ( output[ "scripthash" ].length == 40 && isHex( output[ "scripthash" ] ) ) {
                        var this_address_once_had_money = await thisSpacechainAddressHadMoneyBeforeSpaceblock( hexToBech32( "sc", output[ "scripthash" ] ), wallet_identifier, blocknum, i_am_mining_this_tx );
                        if ( this_address_once_had_money ) {all_outputs_are_valid = false;break;}
                    }
                    //make no further checks on scripthashes, anything unique in the spacechain's history is fine
                    //even if it is not a valid spacechain address -- so basically op_returns are fine
                    if ( !Object.keys( output ).includes( "value" ) ) {all_outputs_are_valid = false;break;}
                    if ( typeof( output[ "value" ] ) != "number" || String( output[ "value" ] ).includes( "." ) ) {all_outputs_are_valid = false;break;}
                    if ( output[ "value" ] < 0 ) {all_outputs_are_valid = false;break;}
                }
                if ( !all_outputs_are_valid ) return;
                var all_inputs_are_valid = true;
                var i; for ( i=0; i<transaction[ "inputs" ].length; i++ ) {
                    var input = transaction[ "inputs" ][ i ];
                    if ( Object.keys( input ).length != 4 && Object.keys( input ).length != 5 ) {all_inputs_are_valid = false;break;}
                    if ( !Object.keys( input ).includes( "redeem_script" ) ) {all_inputs_are_valid = false;break;}
                    if ( !Object.keys( input ).includes( "value" ) ) {all_inputs_are_valid = false;break;}
                    if ( !Object.keys( input ).includes( "output_index" ) ) {all_inputs_are_valid = false;break;}
                    if ( Object.keys( input ).length == 4 && !Object.keys( input ).includes( "burntx" ) ) {all_inputs_are_valid = false;break;}
                    if ( Object.keys( input ).length == 5 && !Object.keys( input ).includes( "blocknum" ) ) {all_inputs_are_valid = false;break;}
                    if ( Object.keys( input ).length == 5 && !Object.keys( input ).includes( "tx_index" ) ) {all_inputs_are_valid = false;break;}
                    if ( typeof( input[ "value" ] ) != "number" || String( input[ "value" ] ).includes( "." ) ) {all_inputs_are_valid = false;break;}
                    if ( typeof( input[ "output_index" ] ) != "number" || String( input[ "output_index" ] ).includes( "." ) ) {all_inputs_are_valid = false;break;}
                    if ( Object.keys( input ).length == 5 && ( typeof( input[ "blocknum" ] ) != "number" || String( input[ "blocknum" ] ).includes( "." ) ) ) {all_inputs_are_valid = false;break;}
                    if ( Object.keys( input ).length == 5 && ( typeof( input[ "tx_index" ] ) != "number" || String( input[ "tx_index" ] ).includes( "." ) ) ) {all_inputs_are_valid = false;break;}
                    if ( !i_am_mining_this_tx && input[ "blocknum" ] > getSpacechainHashes().length ) {all_inputs_are_valid = false;break;}
                    if ( i_am_mining_this_tx && input[ "blocknum" ] > getSpacechainHashes().length + 1 ) {all_inputs_are_valid = false;break;}
                    if ( Object.keys( input ).length == 4 && ( !isHex( input[ "burntx" ] ) || input[ "burntx" ].length != 64 ) ) {all_inputs_are_valid = false;break;}
                    try {
                        var redeem_script = atob( input[ "redeem_script" ] );
                    } catch( e ) {
                        all_inputs_are_valid = false;
                        break;
                    }
                    if ( !isValidJson( redeem_script ) ) {all_inputs_are_valid = false;break;}
                    redeem_script = JSON.parse( redeem_script );
                    if ( !redeem_script.length ) {all_inputs_are_valid = false;break;}
                    var last_witness_element = redeem_script[ redeem_script.length - 1 ];
                    if ( !isHex( last_witness_element ) ) {all_inputs_are_valid = false;break;}
                    var hash_of_last_witness_element = bitcoinjs.crypto.hash160( Buffer.from( last_witness_element, "hex" ) ).toString( "hex" );
                    if ( Object.keys( input ).length == 4 ) {
                        var address_prep = await getData( `https://mempool.space/testnet/api/tx/${input[ "burntx" ]}` );
                        address_prep = JSON.parse( address_prep );
                        if ( address_prep[ "vout" ][ input[ "output_index" ] ][ "scriptpubkey_type" ] != "op_return" ) {all_inputs_are_valid = false;break;}
                        if ( address_prep[ "vout" ][ input[ "output_index" ] ][ "scriptpubkey" ] != "6a34" + hash_of_last_witness_element + $_GET[ "chain" ] ) {all_inputs_are_valid = false;break;}
                        if ( address_prep[ "vout" ][ input[ "output_index" ] ][ "value" ] != input[ "value" ] ) {all_inputs_are_valid = false;break;}
                        var one_of_my_current_utxos_spent_it = false;
                        utxo_set.every( function( utxo ) {
                            var txid_to_check = utxo.split( ":" )[ 0 ] + ":" + utxo.split( ":" )[ 1 ];
                            var tx = getSpacechainTxByTxid( txid_to_check );
                            tx = JSON.parse( tx );
                            if ( utxo.startsWith( String( blocknum ) + ":" + String( txnum ) ) ) return true;
                            if ( thisTransactionFromMyUtxoSetOrItsParentsSpentBurnUtxo( tx, input[ "burntx" ], input[ "output_index" ] ) ) {one_of_my_current_utxos_spent_it = true;return;}
                            return true;
                        });
                        if ( one_of_my_current_utxos_spent_it ) {all_inputs_are_valid = false;break;}
                    } else {
                        var txid = input[ "blocknum" ] + ":" + input[ "tx_index" ];
                        var parent = getSpacechainTxByTxid( txid );
                        if ( !parent ) {all_inputs_are_valid = false;break;}
                        if ( !isValidJson( parent ) ) {all_inputs_are_valid = false;break;}
                        parent = JSON.parse( parent );
                        if ( !Object.keys( parent ).includes( "outputs" ) ) {all_inputs_are_valid = false;break;}
                        if ( !Array.isArray( parent[ "outputs" ] ) ) {all_inputs_are_valid = false;break;}
                        if ( parent[ "outputs" ].length < input[ "output_index" ] ) {all_inputs_are_valid = false;break;}
                        var output = parent[ "outputs" ][ input[ "output_index" ] ];
                        if ( Object.keys( output ).length != 2 ) {all_inputs_are_valid = false;break;}
                        if ( !Object.keys( output ).includes( "scripthash" ) ) {all_inputs_are_valid = false;break;}
                        if ( !Object.keys( output ).includes( "value" ) ) {all_inputs_are_valid = false;break;}
                        if ( typeof( output[ "value" ] ) != "number" || String( output[ "value" ] ).includes( "." ) ) {all_inputs_are_valid = false;break;}
                        if ( output[ "scripthash" ] != hash_of_last_witness_element ) {all_inputs_are_valid = false;break;}
                        if ( output[ "value" ] != input[ "value" ] ) {all_inputs_are_valid = false;break;}
                        if ( !utxo_set.includes( txid + ":" + input[ "output_index" ] ) ) {all_inputs_are_valid = false;break;}
                    }
                    if ( !unlockingScriptIsValid( input[ "redeem_script" ], tx ) ) {all_inputs_are_valid = false;break;}
                }
                if ( !all_inputs_are_valid ) return;
                var sum_of_all_outputs = 0;
                transaction[ "outputs" ].forEach( function( output ) {
                    sum_of_all_outputs = sum_of_all_outputs + output[ "value" ];
                });
                var sum_of_all_inputs = 0;
                transaction[ "inputs" ].forEach( function( input ) {
                    sum_of_all_inputs = sum_of_all_inputs + input[ "value" ];
                });
                if ( sum_of_all_outputs > sum_of_all_inputs ) return;
                if ( do_not_add_to_utxo_set ) return true;
                transaction[ "outputs" ].forEach( function( output, index ) {
                    if ( !isHex( output[ "scripthash" ] ) || output[ "scripthash" ].length != 40 ) return;
                    if ( !utxo_set.includes( String( blocknum ) + ":" + String( txnum ) + ":" + String( index ) ) ) {
                        utxo_set.push( String( blocknum ) + ":" + String( txnum ) + ":" + String( index ) );
                    }
                });
                localStorage[ `utxo_set_for_${wallet_identifier}` ] = JSON.stringify( utxo_set );
                //remove spent txos from the utxo set
                transaction[ "inputs" ].forEach( function( input, index ) {
                    if ( Object.keys( input ).length != 5 ) return;
                    if ( utxo_set.includes( String( input[ "blocknum" ] ) + ":" + String( input[ "tx_index" ] ) + ":" + String( input[ "output_index" ] ) ) ) {
                        utxo_set.splice( utxo_set.indexOf( String( input[ "blocknum" ] ) + ":" + String( input[ "tx_index" ] ) + ":" + String( input[ "output_index" ] ) ), 1 );
                        localStorage[ `utxo_set_for_${wallet_identifier}` ] = JSON.stringify( utxo_set );
                    }
                });
                return true;
            }
            async function getFeesPaidByBlock( block, wallet_identifier, blocknum ) {
                var fees = 0;
                if ( !localStorage[ `utxo_set_for_${wallet_identifier}` ] ) {
                    var utxo_set = [];
                    localStorage[ `utxo_set_for_${wallet_identifier}` ] = JSON.stringify( utxo_set );
                } else {
                    var utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                }
                var good_transactions = [];
                var i; for ( i=0; i<utxo_set.length; i++ ) {
                    var utxo = utxo_set[ i ];
                    if ( Number( utxo.split( ":" )[ 0 ] ) == blocknum && !good_transactions.includes( Number( utxo.split( ":" )[ 1 ] ) ) ) good_transactions.push( Number( utxo.split( ":" )[ 1 ] ) );
                }
                var i; for ( i=0; i<good_transactions.length; i++ ) {
                    var index = i;
                    var transaction = getSpacechainTxByTxid( String( blocknum ) + ":" + String( good_transactions[ i ] ) );
                    transaction = JSON.parse( transaction );
                    var sum_of_all_outputs = 0;
                    transaction[ "outputs" ].forEach( function( output ) {
                        sum_of_all_outputs = sum_of_all_outputs + output[ "value" ];
                    });
                    var sum_of_all_inputs = 0;
                    transaction[ "inputs" ].forEach( function( input ) {
                        sum_of_all_inputs = sum_of_all_inputs + input[ "value" ];
                    });
                    var fee = sum_of_all_inputs - sum_of_all_outputs;
                    fees = fees + fee;
                }
                return fees;
            }
            async function getCoinbaseFromBlock( block, wallet_identifier, blocknum ) {
                var fee = await getFeesPaidByBlock( block, wallet_identifier, blocknum );
                var cb_index = -1;
                var j; for ( j=0; j<block.length; j++ ) {
                    transaction = block[ j ];
                    index = j;
                    if ( index ) {
                        if ( isValidJson( transaction ) ) {
                            transaction = JSON.parse( transaction );
                            if ( Object.keys( transaction ).length == 4 ) {
                                if ( Object.keys( transaction ).includes( "wallet" ) ) {
                                    if ( Object.keys( transaction ).includes( "outputs" ) ) {
                                        if ( Object.keys( transaction ).includes( "timelock" ) ) {
                                            if ( Object.keys( transaction ).includes( "inputs" ) ) {
                                                if ( transaction[ "wallet" ] == wallet_identifier ) {
                                                    if ( Array.isArray( transaction[ "outputs" ] ) ) {
                                                        if ( Array.isArray( transaction[ "inputs" ] ) ) {
                                                            if ( !transaction[ "inputs" ].length ) {
                                                                var all_outputs_are_valid = true;
                                                                var i; for ( i=0; i<transaction[ "outputs" ].length; i++ ) {
                                                                    var output = transaction[ "outputs" ][ i ];
                                                                    if ( Object.keys( output ).length != 2 ) {all_outputs_are_valid = false;break;}
                                                                    if ( !Object.keys( output ).includes( "scripthash" ) ) {all_outputs_are_valid = false;break;}
                                                                    //disallow sending money to the same address twice
                                                                    if ( output[ "scripthash" ].length == 40 && isHex( output[ "scripthash" ] ) ) {
                                                                        var this_address_once_had_money = await thisSpacechainAddressHadMoneyBeforeSpaceblock( hexToBech32( "sc", output[ "scripthash" ] ), wallet_identifier, blocknum );
                                                                        console.log( "this address once had money, right?", !!this_address_once_had_money, hexToBech32( "sc", output[ "scripthash" ] ), wallet_identifier );
                                                                        if ( this_address_once_had_money ) {console.log( "ok, then I am noting that not all outputs are valid in the coinbase of this block!", blocknum );all_outputs_are_valid = false;break;}
                                                                    }
                                                                    //make no further checks on scripthashes, anything unique in the spacechain's history is fine
                                                                    //even if it is not a valid spacechain address -- so basically op_returns are fine
                                                                    if ( !Object.keys( output ).includes( "value" ) ) {all_outputs_are_valid = false;break;}
                                                                    if ( typeof( output[ "value" ] ) != "number" || String( output[ "value" ] ).includes( "." ) ) {all_outputs_are_valid = false;break;}
                                                                }
                                                                if ( all_outputs_are_valid ) {
                                                                    if ( transaction[ "outputs" ][ 0 ][ "value" ] == fee ) {
                                                                        cb_index = index - 1;
                                                                        return cb_index;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return cb_index;
            }
            function getLockingScriptHexFromPrivkey( privkey ) {
                var keys = bitcoinjs.ECPair.fromPrivateKey( Buffer.from( privkey, "hex" ) );
                var pubkey = keys.publicKey.toString( "hex" );
                var keyhash = bitcoinjs.crypto.hash160( keys.publicKey ).toString( "hex" );
                var locking_script_array = [
                    "OP_DUP",
                    "OP_HASH160",
                    keyhash,
                    "OP_EQUALVERIFY",
                    "OP_CHECKSIG"
                ];
                var locking_script_hex = textToHex( JSON.stringify( locking_script_array ) );
                return locking_script_hex;
            }
            function getSpacechainAddressFromPrivkey( privkey ) {
                var locking_script_hex = getLockingScriptHexFromPrivkey( privkey );
                var address = hexToBech32( "sc", bitcoinjs.crypto.hash160( hexToBytes( locking_script_hex ) ).toString( "hex" ) );
                return address;
            }
            async function thisSpacechainAddressOnceHadMoney( address, wallet_identifier ) {
                var hex = bech32ToHex( address );
                var op_return = "6a34" + hex + $_GET[ "chain" ];
                var response = await querier( op_return );
                if ( response && response[ "data" ] && response[ "data" ].length ) return true;
                //check if any valid transaction in my spacechain's history created an output where that address was the scripthash
                //to do that, start with an array of the transactions in my utxo set
                var txs = [];
                var utxo_set = "[]";
                if ( localStorage[ `utxo_set_for_${wallet_identifier}` ] ) {
                    utxo_set = localStorage[ `utxo_set_for_${wallet_identifier}` ];                    
                }
                utxo_set = JSON.parse( utxo_set );
                if ( !utxo_set || !utxo_set.length ) return;
                utxo_set.forEach( function( utxo ) {
                    var txid = utxo.split( ":" )[ 0 ] + ":" + utxo.split( ":" )[ 1 ];
                    txs.push( getSpacechainTxByTxid( txid ) );
                });
                //then add their parents and so forth to that array
                var i; for ( i=0; i<getSpacechainHashes().length; i++ ) {
                    var current_length = String( txs.length );
                    current_length = Number( current_length );
                    txs.forEach( function( tx ) {
                        tx = JSON.parse( tx );
                        tx[ "inputs" ].forEach( function( input ) {
                            if ( Object.keys( input ).length == 5 && !txs.includes( getSpacechainTxByTxid( input[ "blocknum" ] + ":" + input[ "tx_index" ] ) ) ) {
                                txs.push( getSpacechainTxByTxid( input[ "blocknum" ] + ":" + input[ "tx_index" ] ) );
                            }
                        });
                    });
                    //stop if the number of valid transactions in the spacechain's history did not grow
                    if ( txs.length == current_length ) break;
                }
                //check if any of the transactions in the txs array created an output where the address in question was in the scripthash
                var output_was_created = false;
                txs.every( function( tx ) {
                    tx = JSON.parse( tx );
                    tx[ "outputs" ].every( function( output ) {
                        if ( output[ "scripthash" ] == hex ) {output_was_created = true;return;}
                        return true;
                    });
                    if ( output_was_created ) return;
                    return true;
                });
                return output_was_created;
            }
            async function thisSpacechainAddressHadMoneyBeforeSpaceblock( address, wallet_identifier, spaceblocknum, i_am_mining_this_tx ) {
                var had_money = false;
                //when I am mining one of my own transactions I set the spaceblock number to one above my current blockheight
                //I need to correct for this
                if ( i_am_mining_this_tx && spaceblocknum == getSpacechainHashes().length + 1 ) spaceblocknum = spaceblocknum - 1;
                //get the bitcoin block when the spaceblock was anchored
                var anchor_txid = spacechain[ spaceblocknum - 1 ][ 2 ];
                var data = await getData( `https://mempool.space/testnet/api/tx/${anchor_txid}` );
                data = JSON.parse( data );
                //if the block is not mined yet, assume the bitcoin block we are checking against
                //is the current block, otherwise assume it's the block the transaction was
                //anchored in
                var current_blockheight = await getBlockheight();
                if ( !data[ "status" ][ "confirmed" ] ) {
                    var block = current_blockheight;
                } else {
                    var block = data[ "status" ][ "block_height" ];                    
                }
                //check if the address was op_returned before that bitcoin block
                var hex = bech32ToHex( address );
                var op_return = "6a34" + hex + $_GET[ "chain" ];
                var response = await querier( op_return );
                if ( !Object.keys( response ).includes( "data" ) || !response[ "data" ] ) {
                    console.log( response );
                    alert( "You hit the api limit for blockchair's free api.\n\nProbably because, every five seconds, your wallet queries their api about each of your used spacechain addresses to see if there is an op_return on bitcoin that sent them some money.\n\nWait a few minutes before you hit okay and you should be good for another minute or so.\n\nIf this error gets so annoying you are about to scream, ask a developer for help hooking this up to your own node so you don't have to use a permissioned, rate-limited service like blockchair.\n\nYou can also add this to your url to increase the wait time before querying blockchair's api: &number_of_seconds_to_wait_before_rechecking_balance=60\n\nBut be aware it won't work super well if you've made a lot of transactions because it will still make a ton of queries, it will just wait a bit before doing so, and so you will still probably go over blockchair's rate limit." );
                    window.location.reload();
                }
                if ( !Object.keys( response ).includes( "data" ) || !response[ "data" ] ) console.log( response );
                var was_op_returned_in_the_block_in_question = false;
                var earliest_txs_that_sent_it_money = [];
                var earliest_block_id = current_blockheight;
                if ( response && response[ "data" ] && response[ "data" ].length ) {
                    response[ "data" ].forEach( function( item ) {
                        if ( item[ "block_id" ] < block ) had_money = true;
                        if ( item[ "block_id" ] < earliest_block_id ) {
                            earliest_block_id = item[ "block_id" ];
                            earliest_txs_that_sent_it_money = [];
                            earliest_txs_that_sent_it_money.push( item[ "transaction_hash" ] )
                        }
                        if ( item[ "block_id" ] == block ) {
                            was_op_returned_in_the_block_in_question = true;
                            earliest_txs_that_sent_it_money.push( item[ "transaction_hash" ] )
                        }
                    });
                }
                //if it was, return true
                if ( had_money ) return true;
                //if it was not, check if it was op_returned in the block I'm investigating
                //if it was, check if it was op_returned before the transaction in which the spaceblock was anchored
                var address_was_op_returned_first = false;
                if ( was_op_returned_in_the_block_in_question ) {
                    var i; for ( i=0; i<earliest_txs_that_sent_it_money; i++ ) {
                        var item = earliest_txs_that_sent_it_money[ i ];
                        var tx_that_appeared_first = await findWhichTxAppearedFirst( anchor_txid, item );
                        if ( tx_that_appeared_first == item ) {
                            var address_was_op_returned_first = true;
                            break;
                        }
                    }
                }
                //if it was, return true
                if ( address_was_op_returned_first ) return true;
                //console.log( "this address never had money sent to it via bitcoin:", address );
                //if it was not, the first check is false, now proceed to the second check
                //make a copy of my utxo set
                var utxo_set = "[]";
                if ( localStorage[ `utxo_set_for_${wallet_identifier}` ] ) {
                    utxo_set = localStorage[ `utxo_set_for_${wallet_identifier}` ];
                }
                utxo_set = JSON.parse( utxo_set );
                if ( !utxo_set || !utxo_set.length ) return;
                var copy_of_utxo_set = JSON.parse( JSON.stringify( utxo_set ) );
                //throw out all entries that start with a blocknum equal to or higher than the spaceblock number I'm checking
                utxo_set.forEach( function( item, index ) {
                    var items_block = item.split( ":" )[ 0 ];
                    if ( items_block >= spaceblocknum ) {
                        copy_of_utxo_set.splice( index, 1 );
                    }
                });
                utxo_set = JSON.parse( JSON.stringify( copy_of_utxo_set ) );
                //if, in the remaining set, an output sent money to this address, return true
                var txs = [];
                if ( !utxo_set || !utxo_set.length ) return;
                utxo_set.forEach( function( utxo ) {
                    var txid = utxo.split( ":" )[ 0 ] + ":" + utxo.split( ":" )[ 1 ];
                    txs.push( getSpacechainTxByTxid( txid ) );
                });
                //then add their parents and so forth to that array
                var i; for ( i=0; i<getSpacechainHashes().length; i++ ) {
                    var current_length = String( txs.length );
                    current_length = Number( current_length );
                    txs.forEach( function( tx ) {
                        tx = JSON.parse( tx );
                        tx[ "inputs" ].forEach( function( input ) {
                            if ( Object.keys( input ).length == 5 && !txs.includes( getSpacechainTxByTxid( input[ "blocknum" ] + ":" + input[ "tx_index" ] ) ) ) {
                                txs.push( getSpacechainTxByTxid( input[ "blocknum" ] + ":" + input[ "tx_index" ] ) );
                            }
                        });
                    });
                    //stop if the number of valid transactions in the spacechain's history did not grow
                    if ( txs.length == current_length ) break;
                }
                //check if any of the transactions in the txs array created an output where the address in question was in the scripthash
                var output_was_created = false;
                txs.every( function( tx ) {
                    tx = JSON.parse( tx );
                    tx[ "outputs" ].every( function( output ) {
                        if ( output[ "scripthash" ] == hex ) {output_was_created = true;return;}
                        return true;
                    });
                    if ( output_was_created ) return;
                    return true;
                });
                return output_was_created;
            }
            async function getSpacechainAddressBalance( address, wallet_identifier, ignore_op_returns ) {
                var balance = 0;
                var hex = bech32ToHex( address );
                if ( !localStorage[ `utxo_set_for_${wallet_identifier}` ] ) return 0;
                var utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                utxo_set.every( function( utxo ) {
                    var txid = utxo.split( ":" )[ 0 ] + ":" + utxo.split( ":" )[ 1 ];
                    var tx = JSON.parse( getSpacechainTxByTxid( txid ) );
                    var output = tx[ "outputs" ][ utxo.split( ":" )[ 2 ] ];
                    if ( output[ "scripthash" ] == hex ) {balance = output[ "value" ];return;}
                    return true;
                });
                if ( balance || ignore_op_returns ) return balance;
                //if there is no balance according to the spacechain,
                //check if there was ever a balance according to bitcoin's blockchain
                var op_return = "6a34" + hex + $_GET[ "chain" ];
                var response = await querier( op_return );
                if ( !Object.keys( response ).includes( "data" ) || !response[ "data" ] ) {
                    console.log( response );
                    return "error";
                }
                if ( !response[ "data" ].length ) return 0;
                var txid = response[ "data" ][ 0 ][ "transaction_hash" ];
                var output_number = response[ "data" ][ 0 ][ "index" ];
                var is_spent = await checkIfBurnTxIsSpent( txid, output_number, wallet_identifier );
                if ( !is_spent ) balance = response[ "data" ][ 0 ][ "value" ];
                return balance;
            }
            function getSpacechainAddressFromPath( backupwords, path, index ) {
                var privkey = getPrivkeyHexFromPath( backupwords, path, index );
                var address = getSpacechainAddressFromPrivkey( privkey );
                return address;
            }
            async function getFirstUnusedSpacechainAddress( backupwords, wallet_identifier ) {
                var first_unused_address = "";
                var i; for ( i=0; i<1000000; i++ ) {
                    var path = "295'/0'/0'";
                    var address = getSpacechainAddressFromPath( backupwords, path, i );
                    var this_address_once_had_money = await thisSpacechainAddressOnceHadMoney( address, wallet_identifier );
                    if ( !this_address_once_had_money ) {
                        first_unused_address = address;
                        break;
                    }
                }
                return first_unused_address;
            }
            async function getFirstUnusedSpacechainChangeAddress( backupwords, wallet_identifier ) {
                var first_unused_address = "";
                var i; for ( i=0; i<1000000; i++ ) {
                    var path = "295'/0'/1'";
                    var address = getSpacechainAddressFromPath( backupwords, path, i );
                    var this_address_once_had_money = await thisSpacechainAddressOnceHadMoney( address, wallet_identifier );
                    if ( !this_address_once_had_money ) {
                        first_unused_address = address;
                        break;
                    }
                }
                return first_unused_address;
            }
            async function getSecondUnusedSpacechainChangeAddress( backupwords, wallet_identifier ) {
                var second_unused_address = "";
                var index = await getIndexOfFirstUnusedSpacechainChangeAddress( backupwords, wallet_identifier );
                var i; for ( i=index + 1; i<1000000; i++ ) {
                    var path = "295'/0'/1'";
                    var address = getSpacechainAddressFromPath( backupwords, path, i );
                    var this_address_once_had_money = await thisSpacechainAddressOnceHadMoney( address, wallet_identifier );
                    if ( !this_address_once_had_money ) {
                        second_unused_address = getSpacechainAddressFromPath( backupwords, path, i + 1 );;
                        break;
                    }
                }
                return second_unused_address;
            }
            async function getIndexOfFirstUnusedSpacechainAddress( backupwords, wallet_identifier ) {
                var index = -1;
                var i; for ( i=0; i<1000000; i++ ) {
                    var path = "295'/0'/0'";
                    var address = getSpacechainAddressFromPath( backupwords, path, i );
                    var this_address_once_had_money = await thisSpacechainAddressOnceHadMoney( address, wallet_identifier );
                    if ( !this_address_once_had_money ) {
                        index = i;
                        break;
                    }
                }
                return index;
            }
            async function getIndexOfFirstUnusedSpacechainChangeAddress( backupwords, wallet_identifier ) {
                var index = -1;
                var i; for ( i=0; i<1000000; i++ ) {
                    var path = "295'/0'/1'";
                    var address = getSpacechainAddressFromPath( backupwords, path, i );
                    var this_address_once_had_money = await thisSpacechainAddressOnceHadMoney( address, wallet_identifier );
                    if ( !this_address_once_had_money ) {
                        index = i;
                        break;
                    }
                }
                return index;
            }
            async function checkIfBurnTxIsSpent( txid_of_burn_utxo, output_number, wallet_identifier ) {
                var is_spent = false;
                if ( !localStorage[ `utxo_set_for_${wallet_identifier}` ] ) return;
                var utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                var i; for ( i=0; i<utxo_set.length; i++ ) {
                    var utxo = utxo_set[ i ];
                    var txid = utxo.split( ":" )[ 0 ] + ":" + utxo.split( ":" )[ 1 ];
                    var tx = JSON.parse( getSpacechainTxByTxid( txid ) );
                    is_spent = await thisTransactionFromMyUtxoSetOrItsParentsSpentBurnUtxo( tx, txid_of_burn_utxo, output_number );
                    if ( is_spent ) break;
                }
                return is_spent;
            }
            async function getSpacechainBalance( backupwords, wallet_identifier ) {
                if ( sync_in_progress ) return;
                console.log( "updating my balance" );
                var balance = 0;
                var my_utxos = [];
                var index_of_first_unused_address = await getIndexOfFirstUnusedSpacechainAddress( backupwords, wallet_identifier );
                var i; for ( i=0; i<index_of_first_unused_address + 1; i++ ) {
                    var path = "295'/0'/0'";
                    var privkey = getPrivkeyHexFromPath( backupwords, path, i );
                    var pubkey = getPubkeyHexFromPrivkeyHex( privkey );
                    var address = getSpacechainAddressFromPath( backupwords, path, i );
                    var additional_balance = await getSpacechainAddressBalance( address, wallet_identifier );
                    if ( additional_balance == "error" ) return balance;
                    if ( additional_balance ) {
                        var utxo = {}
                        utxo[ "privkey" ] = privkey;
                        utxo[ "pubkey" ] = pubkey;
                        utxo[ "value" ] = additional_balance;
                        var hex = bech32ToHex( address );
                        var spacetx = await getSpacechainAddressBalance( address, wallet_identifier, true );
                        spacetx = !!spacetx;
                        if ( spacetx ) {
                            var utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                            var txo_found = false;
                            utxo_set.every( function( unspent ) {
                                var txid = unspent.split( ":" )[ 0 ] + ":" + unspent.split( ":" )[ 1 ];
                                var tx = JSON.parse( getSpacechainTxByTxid( txid ) );
                                tx[ "outputs" ].every( function( output, index ) {
                                    if ( output[ "scripthash" ] == hex ) {
                                        output_index = index;
                                        utxo[ "blocknum" ] = Number( unspent.split( ":" )[ 0 ] );
                                        utxo[ "tx_index" ] = Number( unspent.split( ":" )[ 1 ] );
                                        utxo[ "output_index" ] = index;
                                        txo_found = true;
                                        return;
                                    }
                                    return true;
                                });
                                if ( txo_found ) return;
                                return true;
                            });
                        } else {
                            var op_return = "6a34" + hex + $_GET[ "chain" ];
                            var response = await querier( op_return );
                            if ( !Object.keys( response ).includes( "data" ) || !response[ "data" ] || !response[ "data" ].length ) {
                                console.log( response );
                                alert( "You hit the api limit for blockchair's free api.\n\nProbably because, every five seconds, your wallet queries their api about each of your used spacechain addresses to see if there is an op_return on bitcoin that sent them some money.\n\nWait a few minutes before you hit okay and you should be good for another minute or so.\n\nIf this error gets so annoying you are about to scream, ask a developer for help hooking this up to your own node so you don't have to use a permissioned, rate-limited service like blockchair.\n\nYou can also add this to your url to increase the wait time before querying blockchair's api: &number_of_seconds_to_wait_before_rechecking_balance=60\n\nBut be aware it won't work super well if you've made a lot of transactions because it will still make a ton of queries, it will just wait a bit before doing so, and so you will still probably go over blockchair's rate limit." );
                                window.location.reload();
                            }
                            utxo[ "burntx" ] = response[ "data" ][ 0 ][ "transaction_hash" ];
                            utxo[ "output_index" ] = response[ "data" ][ 0 ][ "index" ];
                        }
                        my_utxos.push( utxo );
                    }
                    balance = balance + additional_balance;
                }
                var index_of_first_unused_change_address = await getIndexOfFirstUnusedSpacechainChangeAddress( backupwords, wallet_identifier );
                var i; for ( i=0; i<index_of_first_unused_change_address + 1; i++ ) {
                    var path = "295'/0'/1'";
                    var privkey = getPrivkeyHexFromPath( backupwords, path, i );
                    var pubkey = getPubkeyHexFromPrivkeyHex( privkey );
                    var address = getSpacechainAddressFromPath( backupwords, path, i );
                    var additional_balance = await getSpacechainAddressBalance( address, wallet_identifier );
                    if ( additional_balance == "error" ) return balance;
                    if ( additional_balance ) {
                        var utxo = {}
                        utxo[ "privkey" ] = privkey;
                        utxo[ "pubkey" ] = pubkey;
                        utxo[ "value" ] = additional_balance;
                        var hex = bech32ToHex( address );
                        var utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                        var txo_found = false;
                        utxo_set.every( function( unspent ) {
                            var txid = unspent.split( ":" )[ 0 ] + ":" + unspent.split( ":" )[ 1 ];
                            var tx = JSON.parse( getSpacechainTxByTxid( txid ) );
                            tx[ "outputs" ].every( function( output, index ) {
                                if ( output[ "scripthash" ] == hex ) {
                                    output_index = index;
                                    utxo[ "blocknum" ] = Number( unspent.split( ":" )[ 0 ] );
                                    utxo[ "tx_index" ] = Number( unspent.split( ":" )[ 1 ] );
                                    utxo[ "output_index" ] = index;
                                    txo_found = true;
                                    return;
                                }
                                return true;
                            });
                            if ( txo_found ) return;
                            return true;
                        });
                        my_utxos.push( utxo );
                    }
                    balance = balance + additional_balance;
                }
                //var newpriv = "21a9dea505b9535993455951b413bca73f14155bd4385b6c7a972f4dd960a999";
                //var newaddress = getSpacechainAddressFromPrivkey( newpriv );
                //var additional_balance = await getSpacechainAddressBalance( newaddress, wallet_identifier );
                //balance = balance + additional_balance;
                $( '.spacecoin_balance' ).innerText = String( balance ) + " spacecoins";
                console.log( "done updating my balance" );
                sessionStorage[ "my_utxos" ] = JSON.stringify( my_utxos );
            }
            async function processBlock( claimed_block, request_id ) {
                var is_candidate_block = await isCandidateBlock( claimed_block );
                if ( !is_candidate_block ) return;
                if ( request_id && request_id.startsWith( "00000000" ) ) {
                    //do not immediately set the block, instead set
                    //an intermediate variable. If 5 seconds pass without
                    //a competing block coming in, set block_after_theft
                    if ( !sessionStorage[ "potential_fork_block_1" ] ) {
                        sessionStorage[ "potential_fork_block_1" ] = claimed_block;
                    } else if ( sessionStorage[ "potential_fork_block_1" ] != claimed_block ) {
                        sessionStorage[ "potential_fork_block_2" ] = claimed_block;
                        sessionStorage[ "block_after_theft" ] = "fork_alert";
                    }
                    await waitSomeSeconds( 5 );
                    sessionStorage[ "block_after_theft" ] = claimed_block;
                    return;
                }
                if ( request_id && request_id.startsWith( "00000001" ) ) {
                    sessionStorage[ "block_being_sought" ] = claimed_block;
                    console.log( sessionStorage[ "block_being_sought" ] );
                    return;
                }
                var block_hash = bitcoinjs.crypto.sha256( claimed_block ).toString( "hex" );
                claimed_block = JSON.parse( claimed_block );
                //check if the block was anchored into bitcoin
                var candidate_anchors = await getAllTxsInvolvingAddress( "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0" );
                var claimed_anchor_tx = findAnchorAmongCandidates( candidate_anchors, block_hash );
                //if the block is not anchored, ignore it
                if ( !claimed_anchor_tx ) return;
                //check if the block's anchor transaction used an anchor_utxo from your spacechain
                //if the block's anchor transaction is not on my list, ignore it
                if ( !anchor_utxos_in_my_spacechain.includes( claimed_anchor_tx ) ) return;
                //otherwise, if your chain has zero blocks, check that this block's parent is all zeroes
                if (
                    !getSpacechainHashes().length &&
                    claimed_block[ 0 ].substring( 0, 64 ) == "0000000000000000000000000000000000000000000000000000000000000000"
                ) {
                    //it is a new block so add it to your own chain and update your utxo set
                    spacechain.push([ block_hash, JSON.stringify( claimed_block ), claimed_anchor_tx ]);
                    localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                    if ( $_GET[ "wallet_id" ] ) {
                        adjustUtxoSet( claimed_block, $_GET[ "wallet_id" ], getSpacechainHashes().length );
                    }
                    requestBlock( getSpacechainHashes().length + 1 );
                    return;
                } else if (
                    //if it is not all zeroes, check if this block's parent is your latest block
                    getSpacechainHashes().length &&
                    claimed_block[ 0 ].substring( 0, 64 ) == getSpacechainHashes()[ getSpacechainHashes().length - 1 ]
                ) {
                    //it is a new block so add it to your own chain
                    spacechain.push([ block_hash, JSON.stringify( claimed_block ), claimed_anchor_tx ]);
                    localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                    if ( $_GET[ "wallet_id" ] ) {
                        adjustUtxoSet( claimed_block, $_GET[ "wallet_id" ], getSpacechainHashes().length );
                    }
                    requestBlock( getSpacechainHashes().length + 1 );
                    return;
                } else if (
                    getSpacechainHashes().length &&
                    claimed_block[ 0 ].substring( 0, 64 ) != getSpacechainHashes()[ getSpacechainHashes().length - 1 ]
                ) {
                    //if your chain has blocks and this new block does not build on your latest block
                    //then there is a fork, so resolve the fork and resync the chain
                    var latest_block = getBlockFromSpacechain( getSpacechainHashes()[ getSpacechainHashes().length - 1 ] )[ 0 ];
                    await resolveFork( block_hash, bitcoinjs.crypto.sha256( latest_block ).toString( "hex" ) );
                    //resync chain
                    syncChain();
                }
            }
            var queryqueue = [];
            var responsequeue = [];
            var prev_query = 0;
            var prev_504 = 0;
            async function querier( op_return ) {
                //I want this function to continuously add requests to a queue,
                //get the length of the current queue, process your request
                //after waiting 2 seconds multiplied by the length of the
                //queue, return the result, and then reduce the size of the
                //queue by 1
                //I should only make a request to blockchair every 2 seconds
                //because the free api is limited to 30 requests per minute
                var existing_response;
                responsequeue.forEach( function( response, index ) {
                    var copy_of_response_queue = JSON.parse( JSON.stringify( responsequeue ) );
                    //remove responses older than 5 seconds
                    if ( response[ 2 ] < Math.floor( Date.now() / 1000 ) - 5 ) {
                        copy_of_response_queue.splice( index, 1 );
                    }
                    responsequeue = JSON.parse( JSON.stringify( copy_of_response_queue ) );
                });
                //for the remaining responses, if a response exists to a query I just made,
                //return it without making a new request
                responsequeue.every( function( response, index ) {
                    if ( response[ 0 ] == op_return ) {
                        existing_response = response[ 1 ];
                        return;
                    }
                    return true;
                });
                if ( existing_response ) {
                    return existing_response;
                }
                //otherwise make a new response
                if ( !queryqueue.includes( op_return ) ) {queryqueue.push( op_return );}
                var response = await repeatQueryTilGood( op_return );
                var response_for_response_queue = [];
                response_for_response_queue.push( op_return, response, Math.floor( Date.now() / 1000 ) );
                responsequeue.push( response_for_response_queue );
                return response;
            }
            async function repeatQueryTilGood( op_return ) {
                var url = `https://api.blockchair.com/bitcoin/testnet/outputs?q=type(nulldata)&q=script_hex(^${op_return})`;
                if ( prev_query > Math.floor( Date.now() / 1000 ) - 2 ) {
                    if ( prev_504 > Math.floor( Date.now() / 1000 ) - 10 ) {
                        await waitSomeSeconds( 10 );
                    } else {
                        await waitSomeSeconds( 2 );
                    }
                    var response = await repeatQueryTilGood( op_return );
                    return response;
                }
                prev_query = Math.floor( Date.now() / 1000 );
                var response = await getData( url );
                if ( !isValidJson( response ) ) {
                    if ( response.indexOf( "504 Gateway Time-out" ) > -1 ) {
                        console.log( "Oh no, 504!" );
                        prev_504 = Math.floor( Date.now() / 1000 );
                    }
                    console.log( "retrying in 5 seconds because response was not valid json:", response );
                    await waitSomeSeconds( 5 );
                    response = await repeatQueryTilGood( op_return );
                } else {
                    response = JSON.parse( response );
                    if ( !Object.keys( response ).includes( "data" ) || !response[ "data" ] ) {
                        console.log( "retrying in 5 seconds because response was unexpected:", response );
                        await waitSomeSeconds( 5 );
                        response = await repeatQueryTilGood( op_return );
                    }
                }
                return response;
            }
            async function adjustUtxoSet( claimed_block, wallet_identifier, blocknum ) {
                //console.log( "I am asked to adjust the utxo set using data from block", blocknum );
                if ( !localStorage[ `utxo_set_for_${wallet_identifier}` ] ) {
                    var utxo_set = [];
                } else {
                    var utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                }
                var working_utxo_set = JSON.parse( JSON.stringify( utxo_set ) );
                var offset = 0;
                utxo_set.forEach( function( utxo, index ) {
                    var num_it_starts_with = Number( utxo.split( ":" )[ 0 ] );
                    if ( num_it_starts_with > blocknum ) {
                        working_utxo_set.splice( index - offset, 1 );
                        offset = offset + 1;
                        console.log( "utxo set reduced", working_utxo_set );
                    }
                });
                utxo_set = JSON.parse( JSON.stringify( working_utxo_set) );
                localStorage[ `utxo_set_for_${wallet_identifier}` ] = JSON.stringify( utxo_set );
                if ( !claimed_block ) {
                    last_block_synced = blocknum;
                    localStorage[ "last_block_synced" ] = last_block_synced;
                    return;
                }
                if ( sync_in_progress ) {
                    //console.log( "I will not adjust the utxo set using data from block", blocknum, "because an adjustment is already in progress using data from block", last_block_synced + 1 );
                    return;
                }
                sync_in_progress = true;
                $( '.syncing_utxos' ).innerText = "syncing...";
                $( '.assay_block' ).innerText = "Block " + String( blocknum ) + " (this will update as the syncing process moves from block to block)";
                //console.log( "I will now adjust the utxo set using data from block", blocknum );
                var i; for ( i=0; i<claimed_block.length; i++ ) {
                    var index = i;
                    var tx = claimed_block[ i ];
                    if ( !index ) continue;
                    //console.log( `tx ${index} in block ${blocknum}:`, tx );
                    var tx_is_valid = await transactionIsValidWalletTx( tx, false, wallet_identifier, blocknum, index - 1 );
                    //console.log( `tx ${index} in block ${blocknum} is valid, right?`, !!tx_is_valid );
                }
                var coinbase = await getCoinbaseFromBlock( claimed_block, wallet_identifier, blocknum );
                if ( coinbase > -1 ) {
                    var txid_plus_output_number = blocknum + ":" + coinbase + ":0";
                    if ( !localStorage[ `utxo_set_for_${wallet_identifier}` ] ) return;
                    var utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                    if ( !utxo_set.includes( txid_plus_output_number ) ) {
                        utxo_set.push( txid_plus_output_number );
                    }
                    localStorage[ `utxo_set_for_${wallet_identifier}` ] = JSON.stringify( utxo_set );
                }
                //console.log( "done adjusting the utxo set using data from block", blocknum );
                //console.log( "here is the new utxo set:", JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] ) );
                last_block_synced = blocknum;
                localStorage[ "last_block_synced" ] = last_block_synced;
                sync_in_progress = false;
                $( '.syncing_utxos' ).innerText = "Synced";
                $( '.assay_block' ).innerText = "none (this will update as the syncing process moves from block to block)";
            }
            //end of spacechain functions
        </script>
        <script>
            var { getSharedSecret, schnorr, utils } = nobleSecp256k1;
            var crypto  = window.crypto;
            var getRand = size => crypto.getRandomValues( new Uint8Array( size ) );
            var sha256  = bitcoinjs.crypto.sha256;
            var keypair = bitcoinjs.ECPair.makeRandom();
            var privKey = keypair.privateKey.toString( "hex" );
            var pubKey  = keypair.publicKey.toString( "hex" );
            pubKey      = pubKey.substring( 2 );
            console.log( pubKey );
            var relay = "wss://nostr.zebedee.cloud";
            var socket = new WebSocket( relay );

            async function openConnection( e ) {
                console.log( "connected to " + relay );
                //subscribe to messages sent to you
                var subId   = bitcoinjs.ECPair.makeRandom().privateKey.toString( "hex" );
                var filter = {"#p": [ pubKey ]}
                var subscription = [ "REQ", subId, filter ];
                socket.send( JSON.stringify( subscription ) );
                //check who is mining
                var subId2   = bitcoinjs.ECPair.makeRandom().privateKey.toString( "hex" );
                var filter2 = {"kinds": [ 11140 ], "since": Math.floor( Date.now() / 1000 ) - ( 60 * 10 )}
                var subscription2 = [ "REQ", subId2, filter2 ];
                socket.send( JSON.stringify( subscription2 ) );
                if ( sessionStorage[ "mining" ] ) {
                    mineOnLoop();
                    console.log( "mining as:", pubKey );
                } else {
                    console.log( "not mining" );
                }
                if ( !$_GET[ "chain" ] ) return;
            }

            async function handleMessage( message ) {
                var [ type, subId, event ] = JSON.parse( message.data );
                var { kind, content } = event || {}
                if (!event) return;
                if ( kind != 20004 && kind != 11140 ) return;
                var sender = event.pubkey;
                if ( kind === 20004 ) {
                    content = await decrypt( privKey, sender, content );
                }
                message = content;
                var page = "";
                if ( $( '.launch_page' ).style.display != "none" ) {
                    page = "launch_page";
                }
                if ( $( '.mining_center' ).style.display != "none" ) {
                    page = "mining_center";
                }
                if ( isHex( message ) && message.length == 64 ) {
                    //purge old miners from miner lists
                    allminers.forEach( function( miner, index ) {
                        if ( miner[ 1 ] + 600 < Math.floor( Date.now() / 1000 ) ) allminers.splice( index, 1 );
                    });
                    myminers.forEach( function( miner, index ) {
                        if ( miner[ 1 ] + 600 < Math.floor( Date.now() / 1000 ) ) myminers.splice( index, 1 );
                    });
                    //ignore miners on chains you aren't looking for
                    if ( $_GET[ "chain" ] && message != $_GET[ "chain" ] ) return;
                    //ignore yourself
                    if ( sender == pubKey ) return;
                    //ignore miners already on the list
                    var miner_is_in_the_list = false;
                    allminers.every( function( miner ) {
                        if ( miner[ 0 ] == sender ) {
                            miner_is_in_the_list = true;
                            return;
                        }
                        return true;
                    });
                    if ( !miner_is_in_the_list ) {
                        allminers.push( [sender, Math.floor( Date.now() / 1000 )] );
                    }
                    //shuffle the array of miners
                    shuffleArray( allminers );
                    //fill the myminer array
                    allminers.forEach( function( miner ) {
                        //ignore miners already on the myminers list
                        var miner_is_in_the_list = false;
                        myminers.every( function( myminer ) {
                            if ( miner[ 0 ] == myminer[ 0 ] ) {
                                miner_is_in_the_list = true;
                                return;
                            }
                            return true;
                        });
                        //do not talk to more than 8 miners at a time
                        if ( myminers.length >= 8 || miner_is_in_the_list ) return;
                        myminers.push( miner );
                    });
                    //adjust the displayed number of miners on the spacechain
                    var num_of_miners = myminers.length;
                    $( '.num_of_miners' ).innerText = myminers.length;
                    if ( num_of_miners == 1 ) {
                        $( '.is_or_are' ).innerText = "is";
                    } else {
                        $( '.is_or_are' ).innerText = "are";
                    }
                    if ( num_of_miners == 1 ) {
                        $( '.person_or_people' ).innerText = "person";
                    } else {
                        $( '.person_or_people' ).innerText = "people";
                    }
                    return;
                }
                //remove miners who announce they stopped mining
                if ( message == "" ) {
                    var miner_is_in_allminers_list = false;
                    var miner_is_in_myminers_list = false;
                    allminers.forEach( function( miner, index ) {
                        if ( sender == miner[ 0 ] ) miner_is_in_allminers_list = true;
                        allminers.splice( index, 1 );
                    });
                    if ( !miner_is_in_allminers_list ) return;
                    myminers.forEach( function( miner, index ) {
                        if ( sender == miner[ 0 ] ) miner_is_in_myminers_list = true;
                        myminers.splice( index, 1 );
                    });
                    //adjust the displayed number of miners on the spacechain
                    var num_of_miners = myminers.length;
                    $( '.num_of_miners' ).innerText = myminers.length;
                    if ( num_of_miners == 1 ) {
                        $( '.is_or_are' ).innerText = "is";
                    } else {
                        $( '.is_or_are' ).innerText = "are";
                    }
                    if ( num_of_miners == 1 ) {
                        $( '.person_or_people' ).innerText = "person";
                    } else {
                        $( '.person_or_people' ).innerText = "people";
                    }
                    return;
                }
                //console.log( "message:", message, "sent by:", sender );
                if ( !isValidJson( message ) ) return;
                message = JSON.parse( message );
                /*
                //this code is for a planned feature called transaction sponsorship
                //which, if I ever finish it, will allow users to pay other people
                //on the lightning network for enough sats on the base layer to pay
                //the mining fee to create their anchor utxo
                if (
                    "msg_type" in message &&
                    "swap_address" in message &&
                    "swap_invoice" in message &&
                    "server_pubkey" in message &&
                    isHex( message[ "server_pubkey" ] ) &&
                    message[ "server_pubkey" ].length == 66 &&
                    message[ "msg_type" ] == "pay_to_swap_ln_to_bl" &&
                    sender == "09025129315991675a0cef32689af1a5465612691ba376d2f5214175ee860906"
                ) {
                    var feerate = await getMinFeeRate();
                    var expected_amount = ( 546 * 2 ) + ( 300 * feerate ) * 2;
                    var invoice_amount = getInvoiceAmount( message[ "swap_invoice" ] );
                    if ( expected_amount != invoice_amount ) {
                        console.log( "oh no! expected amount:", expected_amount, "invoice amount:", invoice_amount );
                        return;
                    }
                    var blockheight = await getBlockheight();
                    var timelock = blockheight + 2016;
                    var expected_address = getSwapAddress( message[ "server_pubkey" ], sessionStorage[ "user_pubkey" ], sessionStorage[ "payment_hash" ], timelock );
                    var claimed_address = message[ "swap_address" ];
                    if ( claimed_address != expected_address ) {
                        console.log( "oh no! claimed_address:", claimed_address, "expected_address:", expected_address );
                        return;
                    }
                    if ( page == "launch_page" ) {
                        $( '.launch_payment_qr_code' ).innerHTML = ``;
                        $( '.launch_payment_qr_code' ).append( createQR( message[ "swap_invoice" ].toUpperCase() ) );
                        $( '.launch_payment_link' ).href = "lightning:" + message[ "swap_invoice" ];
                        $( '.launch_payment_caption' ).value = "lightning:" + message[ "swap_invoice" ];
                        $( '.launch_payment_amount' ).innerText = Math.ceil( expected_amount / 2 );
                        $( '.launch_payment_address' ).innerText = message[ "swap_address" ];
                        var preimage = sessionStorage[ "preimage" ];
                        var privkey = sessionStorage[ "user_privkey" ];
                        var pubkey = sessionStorage[ "user_pubkey" ];
                        var testnet_anchor_address = "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0";
                        var txid = await waitThenCreate( expected_address, Math.ceil( expected_amount / 2 ), preimage, privkey, pubkey, timelock, message[ "server_pubkey" ], testnet_anchor_address );
                        if ( !isHex( txid ) || txid.length != 64 ) {
                            alert( "Oh no, something went wrong! Please try again." );
                            return;
                        }
                        console.log( "success! Your spaceblock is anchored in this transaction:", txid );
                        step3();
                    }
                    if ( page == "mining_center" ) {
                        $( '.new_block_payment_qr_code' ).innerHTML = ``;
                        $( '.new_block_payment_qr_code' ).append( createQR( message[ "swap_invoice" ].toUpperCase() ) );
                        $( '.new_block_payment_link' ).href = "lightning:" + message[ "swap_invoice" ];
                        $( '.new_block_payment_caption' ).value = "lightning:" + message[ "swap_invoice" ];
                        $( '.new_block_payment_amount' ).innerText = Math.ceil( expected_amount / 2 );
                        $( '.new_block_payment_address' ).innerText = message[ "swap_address" ];
                        var preimage = sessionStorage[ "preimage" ];
                        var privkey = sessionStorage[ "user_privkey" ];
                        var pubkey = sessionStorage[ "user_pubkey" ];
                        var testnet_anchor_address = "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0";
                        var txid = await waitThenMoveAnchor( expected_address, Math.ceil( expected_amount / 2 ), preimage, privkey, pubkey, timelock, message[ "server_pubkey" ], testnet_anchor_address );
                        if ( !isHex( txid ) || txid.length != 64 ) {
                            alert( "Oh no, something went wrong! Please try again." );
                            return;
                        }
                        console.log( "success! Your spaceblock is anchored in this transaction:", txid );
                        var hash = sessionStorage[ "spaceblock_hash" ];
                        var block = JSON.parse( sessionStorage[ "next_spaceblock" ] );
                        spacechain.push([ hash, JSON.stringify( block ), txid ]);
                    }
                }
                */
                if (
                    "msg_type" in message &&
                    message[ "msg_type" ] == "send_block" &&
                    "request_id" in message &&
                    isHex( message[ "request_id" ] ) &&
                    message[ "request_id" ].length == 64
                ) {
                    if ( 
                        "blockhash" in message &&
                        isHex( message[ "blockhash" ] ) &&
                        message[ "blockhash" ].length == 64 &&
                        getBlockFromSpacechain( message[ "blockhash" ] )
                    ) {
                        var response = {}
                        response[ "msg_type" ] = "here_is_block";
                        response[ "request_id" ] = message[ "request_id" ];
                        response[ "block" ] = getBlockFromSpacechain( message[ "blockhash" ] )[ 0 ];
                        response = JSON.stringify( response );
                    }
                    if ( 
                        "blockhash" in message &&
                        isHex( message[ "blockhash" ] ) &&
                        message[ "blockhash" ].length == 64 &&
                        !getBlockFromSpacechain( message[ "blockhash" ] )
                    ) {
                        var response = {}
                        response[ "request_id" ] = message[ "request_id" ];
                        response[ "error" ] = "Block not found";
                        response = JSON.stringify( response );                        
                    }
                    if (
                        "blocknum" in message &&
                        message[ "blocknum" ] &&
                        !isNaN( message[ "blocknum" ] ) &&
                        message[ "blocknum" ] > 0 &&
                        spacechain[ message[ "blocknum" ] - 1 ]
                    ) {
                        var response = {}
                        response[ "msg_type" ] = "here_is_block";
                        response[ "request_id" ] = message[ "request_id" ];
                        response[ "block" ] = spacechain[ message[ "blocknum" ] - 1 ][ 1 ];
                        response = JSON.stringify( response );
                    }
                    if (
                        "blocknum" in message &&
                        message[ "blocknum" ] &&
                        !isNaN( message[ "blocknum" ] ) &&
                        message[ "blocknum" ] > 0 &&
                        !spacechain[ message[ "blocknum" ] - 1 ]
                    ) {
                        var response = {}
                        response[ "request_id" ] = message[ "request_id" ];
                        response[ "error" ] = "Block not found";
                        response = JSON.stringify( response );                        
                    }
                    if ( !response ) {
                        var response = {}
                        response[ "request_id" ] = message[ "request_id" ];
                        response[ "error" ] = "malformed request, please try again";
                        response = JSON.stringify( response );
                    }
                    var recipient = sender;
                    var encrypted = encrypt( privKey, recipient, response );
                    var event = {
                        "content"    : encrypted,
                        "created_at" : Math.floor( Date.now() / 1000 ),
                        "kind"       : 20004,
                        "tags"       : [ [ 'p', recipient ] ],
                        "pubkey"     : pubKey,
                    }
                    var signedEvent = await getSignedEvent( event, privKey );
                    socket.send( JSON.stringify( [ "EVENT", signedEvent ] ) );
                }
                if (
                    "msg_type" in message &&
                    message[ "msg_type" ] == "here_is_block" &&
                    "request_id" in message &&
                    isHex( message[ "request_id" ] ) &&
                    message[ "request_id" ].length == 64 &&
                    "block" in message &&
                    pending_block_requests.includes( message[ "request_id" ] )
                ) {
                    //remove the pending block request
                    pending_block_requests.splice( pending_block_requests.indexOf( message[ "request_id" ] ), 1 );
                    //you got a block, which either means there is a fork, a new block, or a troll
                    //check if it's a valid spaceblock candidate to see if it's a troll
                    var claimed_block = message[ "block" ];
                    processBlock( claimed_block, message[ "request_id" ] );
                }
                if (
                    "request_id" in message &&
                    pending_block_requests.includes( message[ "request_id" ] )
                ) {
                    //remove the pending block request
                    pending_block_requests.splice( pending_block_requests.indexOf( message[ "request_id" ] ), 1 );
                }
            }

            socket.addEventListener( 'message', handleMessage );
            socket.addEventListener( 'open', openConnection );

            function startMining() {
                sessionStorage[ "mining" ] = true;
                mineOnLoop();
                console.log( "mining as:", pubKey );
                var button = document.createElement( "button" );
                button.innerText = "Deregister as a miner of this spacechain";
                button.onclick = function() {stopMining();}
                $( '.miner_registration' ).innerHTML = "";
                $( '.miner_registration' ).append( button );
                $( '.mine_new_block' ).style.display = "inline";
                $( '.hidden_mining_info' ).style.display = "block";
            }

            function stopMining() {
                sessionStorage.removeItem( "mining" );
                announceIStoppedMining();
                console.log( "not mining" );                
                var button = document.createElement( "button" );
                button.innerText = "Register as a miner of this spacechain";
                button.onclick = function() {startMining();}
                $( '.miner_registration' ).innerHTML = "";
                $( '.miner_registration' ).append( button );
                $( '.mine_new_block' ).style.display = "none";
                $( '.hidden_mining_info' ).style.display = "none";
                $( '.new_block_payment_div_container' ).style.display = "none";
            }

            async function getSignedEvent(event, privateKey) {
                var eventData = JSON.stringify([
                    0,                    // Reserved for future use
                    event['pubkey'],        // The sender's public key
                    event['created_at'],    // Unix timestamp
                    event['kind'],        // Message “kind” or type
                    event['tags'],        // Tags identify replies/recipients
                    event['content']        // Your note contents
                ])
                event.id  = sha256( eventData ).toString( 'hex' )
                event.sig = await schnorr.sign( event.id, privateKey ) 
                return event
            }
            //put this right above your closing script tag
            function encrypt( privkey, pubkey, text ) {
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var iv = window.crypto.getRandomValues(new Uint8Array(16));
                var cipher = browserifyCipher.createCipheriv( 'aes-256-cbc', hexToBytes( key ), iv );
                var encryptedMessage = cipher.update(text,"utf8","base64");
                emsg = encryptedMessage + cipher.final( "base64" );
                var uint8View = new Uint8Array( iv.buffer );
                var decoder = new TextDecoder();
                return emsg + "?iv=" + btoa( String.fromCharCode.apply( null, uint8View ) );
            }
            //put this right above your closing script tag
            function decrypt( privkey, pubkey, ciphertext ) {
                var [ emsg, iv ] = ciphertext.split( "?iv=" );
                var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );
                var decipher = browserifyCipher.createDecipheriv(
                    'aes-256-cbc',
                    hexToBytes( key ),
                    hexToBytes( base64ToHex( iv ) )
                );
                var decryptedMessage = decipher.update( emsg, "base64" );
                dmsg = decryptedMessage + decipher.final( "utf8" );
                return dmsg;
            }
            async function prepareAnchor() {
                var page = "";
                if ( $( '.launch_page' ).style.display && $( '.launch_page' ).style.display != "none" ) {
                    page = "launch_page";
                }
                if ( $( '.mining_center' ).style.display && $( '.mining_center' ).style.display != "none" ) {
                    page = "mining_center";
                }
                var keypair = bitcoinjs.ECPair.makeRandom();
                var privkey = keypair.privateKey.toString( "hex" );
                var pubkey = keypair.publicKey.toString( "hex" );
                var feerate = await getMinFeeRate();
                var amount = 546 + ( 300 * feerate );
                var blockheight = await getBlockheight();
                var timelock = blockheight + 2016;
                var preimage = bitcoinjs.ECPair.makeRandom().privateKey.toString( "hex" );
                var payment_hash = bitcoinjs.crypto.sha256( hexToBytes( preimage ) ).toString( "hex" );
                var swap_address = getSwapAddress( pubkey, pubkey, payment_hash, timelock );
                sessionStorage[ "utxo_data" ] = JSON.stringify( {"privkey":privkey,"pubkey":pubkey,"preimage":preimage,"pmthash":payment_hash,"timelock":timelock,"amount":amount} );
                if ( page == "launch_page" ) {
                    $( '.launch_payment_qr_code' ).innerHTML = ``;
                    $( '.launch_payment_qr_code' ).append( createQR( swap_address.toUpperCase() ) );
                    $( '.launch_payment_link' ).href = "bitcoin:" + swap_address;
                    $( '.launch_payment_caption' ).value = "bitcoin:" + swap_address;
                    $( '.launch_payment_amount' ).innerText = amount;
                    $( '.launch_payment_address' ).innerText = swap_address;
                    var testnet_anchor_address = "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0";
                    var txid = await waitThenCreate( swap_address, amount, preimage, privkey, pubkey, timelock, pubkey, testnet_anchor_address );
                    if ( !isHex( txid ) || txid.length != 64 ) {
                        alert( "Oh no, something went wrong! Please try again." );
                        return;
                    }
                    alert( "success! Your spaceblock is anchored in this transaction: " + txid );
                    var hash = sessionStorage[ "spaceblock_hash" ];
                    var block = JSON.parse( sessionStorage[ "next_spaceblock" ] );
                    spacechain = [];
                    anchor_utxos_in_my_spacechain = [];
                    anchor_utxos_in_my_spacechain.push( txid );
                    localStorage[ "anchor_utxos_in_my_spacechain" ] = JSON.stringify( anchor_utxos_in_my_spacechain );
                    spacechain.push([ hash, JSON.stringify( block ), txid ]);
                    localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                    sessionStorage[ "spaceblock_hash" ] = "";
                    sessionStorage[ "next_spaceblock" ] = "";
                    console.log( "my spacechain:", spacechain );
                    window.location.href = window.location.protocol + "//" + window.location.hostname + window.location.pathname + "?chain=" + txid;
                }
                if ( page == "mining_center" ) {
                    $( '.new_block_payment_qr_code' ).innerHTML = ``;
                    $( '.new_block_payment_qr_code' ).append( createQR( swap_address.toUpperCase() ) );
                    $( '.new_block_payment_link' ).href = "bitcoin:" + swap_address;
                    $( '.new_block_payment_caption' ).value = "bitcoin:" + swap_address;
                    $( '.new_block_payment_amount' ).innerText = amount;
                    $( '.new_block_payment_address' ).innerText = swap_address;
                    var testnet_anchor_address = "tb1qhutjenkpvjltlpuscqpnpj8gpdxh2s6xdw63quzpzhvqjs90grtssaqrd0";
                    var txid = await waitThenMoveAnchor( swap_address, amount, preimage, privkey, pubkey, timelock, pubkey, testnet_anchor_address );
                    if ( !isHex( txid ) || txid.length != 64 ) {
                        alert( "Oh no, something went wrong! Please try again." );
                        return;
                    }
                    alert( "success! Your spaceblock is anchored in this transaction: " + txid );
                    var hash = sessionStorage[ "spaceblock_hash" ];
                    var block = JSON.parse( sessionStorage[ "next_spaceblock" ] );
                    spacechain.push([ hash, JSON.stringify( block ), txid ]);
                    localStorage[ "spacechain" ] = JSON.stringify( spacechain );
                    sessionStorage[ "spaceblock_hash" ] = "";
                    sessionStorage[ "next_spaceblock" ] = "";
                }
            }
            async function requestSwap() {
                var message = {}
                message[ "msg_type" ] = "swap_from_lightning_to_base_layer";
                var keypair = bitcoinjs.ECPair.makeRandom();
                var privkey = keypair.privateKey.toString( "hex" );
                var pubkey = keypair.publicKey.toString( "hex" );
                sessionStorage[ "user_privkey" ] = privkey;
                sessionStorage[ "user_pubkey" ] = pubkey;
                var preimage = bitcoinjs.ECPair.makeRandom().privateKey.toString( "hex" );
                sessionStorage[ "preimage" ] = preimage;
                var payment_hash = bitcoinjs.crypto.sha256( hexToBytes( preimage ) ).toString( "hex" );
                sessionStorage[ "payment_hash" ] = payment_hash;
                console.log( "preimage:", preimage );
                console.log( "payment_hash:", payment_hash );
                message[ "payment_hash" ] = payment_hash;
                message[ "user_pubkey" ] = pubkey;
                message[ "amount" ] = 546;
                message = JSON.stringify( message );
                var recipient = "09025129315991675a0cef32689af1a5465612691ba376d2f5214175ee860906";
                var encrypted = encrypt( privKey, recipient, message );
                var event = {
                    "content"    : encrypted,
                    "created_at" : Math.floor( Date.now() / 1000 ),
                    "kind"       : 20004,
                    "tags"       : [ [ 'p', recipient ] ],
                    "pubkey"     : pubKey,
                }
                var signedEvent = await getSignedEvent( event, privKey );
                socket.send( JSON.stringify( [ "EVENT", signedEvent ] ) );
            }
            async function announceIStartedMining( chain ) {
                if ( !chain ) {
                    var chain = "25594d702f285977c5c127bb4b6dc9564b73f82ae67a39b5ec8743ffbba554d6";
                }
                var event = {
                    "content"    : chain,
                    "created_at" : Math.floor( Date.now() / 1000 ),
                    "kind"       : 11140,
                    "tags"       : [],
                    "pubkey"     : pubKey,
                }
                var signedEvent = await getSignedEvent( event, privKey );
                socket.send( JSON.stringify( [ "EVENT", signedEvent ] ) );
            }
            async function announceIStoppedMining() {
                var event = {
                    "content"    : "",
                    "created_at" : Math.floor( Date.now() / 1000 ),
                    "kind"       : 11140,
                    "tags"       : [],
                    "pubkey"     : pubKey,
                }
                var signedEvent = await getSignedEvent( event, privKey );
                socket.send( JSON.stringify( [ "EVENT", signedEvent ] ) );
            }
            function mineOnLoop() {
                if ( !sessionStorage[ "mining" ] ) return;
                announceIStartedMining( $_GET[ "chain" ] );
                //announce yourself every 12 hours
                setTimeout( function() {mineOnLoop();}, 60000 * 10 );
            }
            function requestBlock( num_or_hash, investigating_theft, tracing_history ) {
                //console.log( "I will request block", num_or_hash );
                var blocks = [];
                blocks.push( JSON.stringify( ["0000000000000000000000000000000000000000000000000000000000000000a88800eacc0567c3799562cb7ea9f9932a6c2e76d1881be158486883fc6be08b","{\"spacechain_name\":\"Test chain\",\"spacechain_msg\":\"test message\"}"] ) );
                blocks.push( JSON.stringify( ["8080828e4d82434e4e5a9cb2434224fb5ecee23a6359d09e7608bcfbc0597b24000834880f155d3719b4485d5c2afc97d3b60fcc58aa61ae1c048c02dabfcad0","second block woot"] ) );
                blocks.push( JSON.stringify( ["bce8697fc079c2b58dbe64e6fb5068ea9e35c1afed26f35697262fbf6b5041f950920d1ea99cc88ed832f1c15882dbd5ab5770f368842775038093ffa5c6f757","This is the third spaceblock and I have become exceedingly efficient at it."] ) );
                blocks.push( JSON.stringify( ["898068d17894c438e99953695b0270068115aae532ebeda8d8310554ac45e4b065649d2fcd775595c97e726eb9be7db3b86fab960d667a7563fcc6293ea1b10a","Block 4 is here and I want to see what happens if I put an emoji in it 🍉"] ) );
                blocks.push( JSON.stringify( ["5324c432089255987cbd621e442799d666c529c87e9146f5cb0394debe798968c5486adb67c15aafa10ab8300205fd28df6f987ae9504bf21fe2b05857a63cdb","This is a real block"] ) );
                blocks.push( JSON.stringify( ["8bc105a901b4f3cf90844ad38b9cb2aed65415c216bac72d85fee7f11b4f1f9a3ffcf71ea0edc6dc7974ce8966891209f9fa1b9d801488bd26fa654546dc96f7","test1","test2","test3"] ) );
                blocks.push( JSON.stringify( ["8bedb41c8f641933d6ce74560bf10de286cae64479f18b3ac840cadcd2840836f4a0b4ee854f67f8e9bc96120919913cb341e7d344c8ce8b540a16e7ddd44a4e","{\"wallet\":\"5c2dfbbfb0cafe0c56efec3fcf9a83a776f13173338ddc2cb8ced74152d320be\",\"inputs\":[],\"outputs\":[{\"scripthash\":\"abababababababababababababababababababab\",\"value\":200}],\"timelock\":1}","{\"wallet\":\"5c2dfbbfb0cafe0c56efec3fcf9a83a776f13173338ddc2cb8ced74152d320be\",\"inputs\":[{\"burntx\":\"285682de6c6b8ac4ed0a99d90353e7cde12598da4322667b1de6716311483697\",\"output_index\":0,\"value\":700,\"redeem_script\":\"WyIzZmY1M2QwYWI4N2UxNGY0YWZjZThhNGFlMzE3NmFlOTkyN2EzN2FjMmUyODY4ZTVjOTgxYzMwNzY4ZTQ4ZmU2NjFkM2ZmZmIyMzJhMjgxNDI2MzgyMGZmMjJhYWI0ZWJhNTlkMjA0OTEyNzgxYWE5ZTJkMmM3NzI1Y2RhMzQ4ZC1bKl0tWypdIiwiMDMzZDgyMTQ0ZjQ3YjM1NmE3NTVjYzM1ZWIzNjE5MzM5MjNkZmQ3OWEwNTVhNjQ4OWRmYWUzZjdmOTRlYjBlNWRiIiwiNWIyMjRmNTA1ZjQ0NTU1MDIyMmMyMjRmNTA1ZjQ4NDE1MzQ4MzEzNjMwMjIyYzIyMzMzNTM5MzczNTM0MzkzMTY2NjEzMzY0MzMzODYzNjMzNTMwMzkzNDYzMzk2NDM0MzQzNzYxMzk2NjM0MzMzNTM5MzQzMDM4MzkzMjM2MzIyMjJjMjI0ZjUwNWY0NTUxNTU0MTRjNTY0NTUyNDk0NjU5MjIyYzIyNGY1MDVmNDM0ODQ1NDM0YjUzNDk0NzIyNWQiXQ==\"}],\"outputs\":[{\"scripthash\":\"8b67c10d3688745b5fdd9603e69c1b7e51564960\",\"value\":500}],\"timelock\":1}"] ) );
                blocks.push( JSON.stringify( ["76ee75c9ed0530b8f9c7f9ac1c0b1acb12388d7459217da9dbe420c7435b9d411ab3db6fb62fd3c626852dfe3f18236f5efda7791c1516afad15a93825b42f55","{\"wallet\":\"5c2dfbbfb0cafe0c56efec3fcf9a83a776f13173338ddc2cb8ced74152d320be\",\"inputs\":[],\"outputs\":[{\"scripthash\":\"c8553f587df9f6a3d31fafe6ba831ce786a2c3e5\",\"value\":50}],\"timelock\":1}","{\"wallet\":\"5c2dfbbfb0cafe0c56efec3fcf9a83a776f13173338ddc2cb8ced74152d320be\",\"inputs\":[{\"output_index\":0,\"value\":700,\"redeem_script\":\"WyIxMmEzNDllNzQ0MWVkYjU1YTViNWQzODQwYzg4NTU5ZDc5ZjU3OWU2MzI2YjA2YWVjNWIyNzgyMDY5Y2FmNzczMWVhMWU4Zjc1YmQ2OWQ3MWVlYTA2ZDUxNTFmMmRhMmJlYjZhYWI2MzliYmExNGQ2ZmE4YzJlNzU1MmRiMTNiZi1bKl0tWypdIiwiMDJhOTA4ODA4OTk5Mzk3N2E5YTAyYjE2ZTc2ODMwYWFlZDNlMTQ3OTQ2OTFhMzJlYjM2NzA5MDhiMjEyNTk2Y2NjIiwiNWIyMjRmNTA1ZjQ0NTU1MDIyMmMyMjRmNTA1ZjQ4NDE1MzQ4MzEzNjMwMjIyYzIyMzQzNTMxMzgzNjMzMzMzMzM4NjQ2MjM5MzQ2NDM0NjEzNTM3MzIzNTYyMzg2NDM5MzczNTY2MzczOTMyNjE2NjYyMzEzNjY0NjQzODM1MzkyMjJjMjI0ZjUwNWY0NTUxNTU0MTRjNTY0NTUyNDk0NjU5MjIyYzIyNGY1MDVmNDM0ODQ1NDM0YjUzNDk0NzIyNWQiXQ==\",\"burntx\":\"84d1825095d649355ae54b117fc0e2bba204f42597ba89bb20d37e8fbaff679c\"}],\"outputs\":[{\"scripthash\":\"3f8fdaccfa851ef7d4d51c348a1f5bfaa88a8a2e\",\"value\":500},{\"scripthash\":\"c8553f587df9f6a3d31fafe6ba831ce786a2c3e5\",\"value\":150}],\"timelock\":1}"] ) );
                blocks.push( JSON.stringify( ["f59674aec0b33fef27d3216d6c1371daa0d286762d150daa418b8e565ed70b9cb4cdb5d13bff92c472f5736f0830fae044ab1a6a806649b414cf7c7f089c7a4e","{\"wallet\":\"5c2dfbbfb0cafe0c56efec3fcf9a83a776f13173338ddc2cb8ced74152d320be\",\"inputs\":[],\"outputs\":[{\"scripthash\":\"d88670dcced0b8a39f8a8818aec124eefad04f98\",\"value\":200}],\"timelock\":1}","{\"wallet\":\"5c2dfbbfb0cafe0c56efec3fcf9a83a776f13173338ddc2cb8ced74152d320be\",\"inputs\":[{\"output_index\":0,\"value\":500,\"redeem_script\":\"WyI2YjQ2ZTk0OTc5NWFjODg1NWVmYWUxYzM5ZjUwNTA0OWJiZDU1ZmM0N2I5YmFlMjVkMWM2NmE0NTVjZDk3N2Q1MmEyOGJkZTI1YzQ1ODdhNjUxYjg4NjMyYTU5YmQ1Zjk4MzQ2YzExY2E3N2EwZWRmOGQ4OTkxNTc2ZWZiMWIwNy1bKl0tWypdIiwiMDJhZDJmYjExMzNkMzIwMjhjNDZhMzczOTA0ZjIwMzQyOWVlNDM1ZDRjYWYxNmNiYmU2ZDFjYjNjYTczMjAyZjU1IiwiNWIyMjRmNTA1ZjQ0NTU1MDIyMmMyMjRmNTA1ZjQ4NDE1MzQ4MzEzNjMwMjIyYzIyNjI2NjM3Mzk2NDM4MzczMDMzNjYzMTM0MzM2MjMwNjI2NTMyNjMzNTM3NjYzODY1MzI2NDM2MzkzMTMxNjY2NjM5NjY2NDM1MzkzNTMwMzMyMjJjMjI0ZjUwNWY0NTUxNTU0MTRjNTY0NTUyNDk0NjU5MjIyYzIyNGY1MDVmNDM0ODQ1NDM0YjUzNDk0NzIyNWQiXQ==\",\"blocknum\":8,\"tx_index\":1},{\"output_index\":1,\"value\":150,\"redeem_script\":\"WyI1NzBlMmFkNWFkYmJhYTAzOTU5NzkwOThiOTc1ZGQxNzZjZjk0MzEwNzY1ZGNhM2RjZWMwNjFlNjViMjI4YjA1NTQ2YTdiNWViYTQ2ZDU5NTNjNWZhNjcyM2E3MzNkYmYzNzcwNGJjZTkwYjg0MTlkYTk2NmM1MTU1N2U3YTU4ZS1bKl0tWypdIiwiMDM3ZDkyZGE2N2Q1N2Q3YTA4ZmJiNGQyNjRjZTc4YTVjYzVlZmYyZjkzNDViNzJiMDQ4YTFiYTllOTc1Yjg3MGY1IiwiNWIyMjRmNTA1ZjQ0NTU1MDIyMmMyMjRmNTA1ZjQ4NDE1MzQ4MzEzNjMwMjIyYzIyMzA2NDMwMzIzMjYzNjI2NDM5NjQzMDMyMzMzMTY0NjYzOTMzNjYzMjM2NjYzMzYzMzA2NDM4NjUzMzMxNjY2NjMzMzczOTM1NjMzMzYxNjEyMjJjMjI0ZjUwNWY0NTUxNTU0MTRjNTY0NTUyNDk0NjU5MjIyYzIyNGY1MDVmNDM0ODQ1NDM0YjUzNDk0NzIyNWQiXQ==\",\"blocknum\":8,\"tx_index\":1}],\"outputs\":[{\"scripthash\":\"ad545e233c4304e8eb85b4e7f582264bca4bdaaa\",\"value\":600},{\"scripthash\":\"0c61a4d5599b8690f14d391d3db65256b29b9fd2\",\"value\":-150}],\"timelock\":1}"] ) );
                blocks.push( JSON.stringify( ["763222e9fa5b48426f6f1cb7753709e765838065c9367c1b7f7650ede4ade1c138cb3d444c32ef0c37020fb6c922ae26bd033d2dc3bec22c290349e356456038","{\"wallet\":\"5c2dfbbfb0cafe0c56efec3fcf9a83a776f13173338ddc2cb8ced74152d320be\",\"inputs\":[],\"outputs\":[{\"scripthash\":\"d88670dcced0b8a39f8a8818aec124eefad04f98\",\"value\":50}],\"timelock\":1}","{\"wallet\":\"5c2dfbbfb0cafe0c56efec3fcf9a83a776f13173338ddc2cb8ced74152d320be\",\"inputs\":[{\"output_index\":0,\"value\":500,\"redeem_script\":\"WyIxZDgxMmZlNzE2MWVlYzZiN2ZlMjE5ZWVkYTU4ZmM2MzZjMWE3MmYzMDNkZmZjYmQ2N2ZiZWEzYWUwYjUwNTdhMDYxODY1YWZlOGNiNjU3NzNmZDY5OTViNjc2NjU2YWU2OGEwMDU2ODc2OWNhMTY1NWY2Y2VhMTk2MmNjZjgyMS1bKl0tWypdIiwiMDJhZDJmYjExMzNkMzIwMjhjNDZhMzczOTA0ZjIwMzQyOWVlNDM1ZDRjYWYxNmNiYmU2ZDFjYjNjYTczMjAyZjU1IiwiNWIyMjRmNTA1ZjQ0NTU1MDIyMmMyMjRmNTA1ZjQ4NDE1MzQ4MzEzNjMwMjIyYzIyNjI2NjM3Mzk2NDM4MzczMDMzNjYzMTM0MzM2MjMwNjI2NTMyNjMzNTM3NjYzODY1MzI2NDM2MzkzMTMxNjY2NjM5NjY2NDM1MzkzNTMwMzMyMjJjMjI0ZjUwNWY0NTUxNTU0MTRjNTY0NTUyNDk0NjU5MjIyYzIyNGY1MDVmNDM0ODQ1NDM0YjUzNDk0NzIyNWQiXQ==\",\"blocknum\":8,\"tx_index\":1},{\"output_index\":1,\"value\":150,\"redeem_script\":\"WyI1YjVlZDIzZGExYTQxZjczYmU5MzMyMWI3MDMxMjc2ZDU2MzBkOGUzZDc4YWY1MzAyMDQ2NzVkNTZmMjg3N2FhN2Q3NDhhYTdkZDY1ZTAwYmI5M2Y1YmMyOWIxMWI0ZmM4YmIxOGJjNTczMjBhMzdmNTRjZDNkNTM1YWNhNjM4ZS1bKl0tWypdIiwiMDM3ZDkyZGE2N2Q1N2Q3YTA4ZmJiNGQyNjRjZTc4YTVjYzVlZmYyZjkzNDViNzJiMDQ4YTFiYTllOTc1Yjg3MGY1IiwiNWIyMjRmNTA1ZjQ0NTU1MDIyMmMyMjRmNTA1ZjQ4NDE1MzQ4MzEzNjMwMjIyYzIyMzA2NDMwMzIzMjYzNjI2NDM5NjQzMDMyMzMzMTY0NjYzOTMzNjYzMjM2NjYzMzYzMzA2NDM4NjUzMzMxNjY2NjMzMzczOTM1NjMzMzYxNjEyMjJjMjI0ZjUwNWY0NTUxNTU0MTRjNTY0NTUyNDk0NjU5MjIyYzIyNGY1MDVmNDM0ODQ1NDM0YjUzNDk0NzIyNWQiXQ==\",\"blocknum\":8,\"tx_index\":1}],\"outputs\":[{\"scripthash\":\"ad545e233c4304e8eb85b4e7f582264bca4bdaaa\",\"value\":600}],\"timelock\":1}"] ) );
                if ( $_GET[ "fastsync" ] && typeof( num_or_hash ) && num_or_hash <= blocks.length + 1 ) {
                    processBlock( blocks[ num_or_hash - 1 ] );
                    return;
                }
                //ask each miner for your latest block and the block after it
                //a function in handleMessage
                var offset = 0;
                myminers.forEach( async function( miner, index ) {
                    var message = {}
                    message[ "msg_type" ] = "send_block";
                    var request_id = bitcoinjs.ECPair.makeRandom().privateKey.toString( "hex" );
                    if ( investigating_theft ) {
                        request_id = "00000000" + request_id;
                        request_id = request_id.substring( 0, 64 );
                    }
                    if ( tracing_history ) {
                        request_id = "00000001" + request_id;
                        request_id = request_id.substring( 0, 64 );
                    }
                    message[ "request_id" ] = request_id;
                    if ( !isNaN( num_or_hash ) ) {
                        message[ "blocknum" ] = num_or_hash;
                    } else {
                        message[ "blockhash" ] = num_or_hash;                        
                    }
                    message   = JSON.stringify( message );
                    var recipient = miner[ 0 ];
                    //console.log( recipient );
                    var encrypted = encrypt( privKey, recipient, message );
                    var event = {
                        "content"    : encrypted,
                        "created_at" : Math.floor( Date.now() / 1000 ),
                        "kind"       : 20004,
                        "tags"       : [ [ 'p', recipient ] ],
                        "pubkey"     : pubKey,
                    }
                    var signedEvent = await getSignedEvent( event, privKey );
                    pending_block_requests.push( request_id );
                    //remove the pending block request if 10 seconds go by with no answer
                    //if an answer does come, a function in handleMessage will remove it
                    setTimeout( function() {
                        if ( !pending_block_requests.includes( request_id ) ) return;
                        myminers.splice( index - offset, 1 );
                        offset = offset + 1;
                        pending_block_requests.splice( pending_block_requests.indexOf( request_id ), 1 );
                        //adjust the displayed number of miners on the spacechain
                        var num_of_miners = myminers.length;
                        $( '.num_of_miners' ).innerText = myminers.length;
                        if ( num_of_miners == 1 ) {
                            $( '.is_or_are' ).innerText = "is";
                        } else {
                            $( '.is_or_are' ).innerText = "are";
                        }
                        if ( num_of_miners == 1 ) {
                            $( '.person_or_people' ).innerText = "person";
                        } else {
                            $( '.person_or_people' ).innerText = "people";
                        }
                    }, 10000 );
                    socket.send( JSON.stringify( [ "EVENT", signedEvent ] ) );
                });
            }
            async function syncChain() {
                if ( !$_GET[ "chain" ] ) return;
                if ( $_GET[ "fastsync" ] ) requestBlock( getSpacechainHashes().length + 1 );
                //console.log( "started syncing headers..." );
                await returnAnchorTxidsTilTheftOrCurrentBlockheight( chain_til_theft_or_blockheight );
                //console.log( "almost done syncing headers..." );
                await returnLatestAnchorTxidOrThatNewOneMustBeMade( $_GET[ "chain" ] );
                //console.log( "syncing chain!" );
                if ( !!myminers.length || !$_GET[ "fastsync" ] ) requestBlock( getSpacechainHashes().length + 1 );
            }
            function checkHeartbeat( num ) {
                if ( socket && socket.readyState == 3 ) {
                    socket.removeEventListener( 'open', openConnection );
                    socket.removeEventListener( 'message', handleMessage );
                    socket = new WebSocket( relay );
                    socket.addEventListener( 'message', handleMessage );
                    socket.addEventListener( 'open', openConnection );
                }
                //every 5 seconds, sync the utxo set
                if ( $_GET[ "wallet_id" ] && num % 10 == 0 && getSpacechainHashes().length > Number( localStorage[ "last_block_synced" ] ) ) {
                    adjustUtxoSet( JSON.parse( spacechain[ Number( localStorage[ "last_block_synced" ] ) ][ 1 ] ), $_GET[ "wallet_id" ], Number( localStorage[ "last_block_synced" ] ) + 1 );
                }
                //every 15 seconds, get the spacechain's balance
                var wallet_identifier = $_GET[ "wallet_id" ];
                var double_the_number_of_seconds_to_wait = 30;
                if ( $_GET[ "number_of_seconds_to_wait_before_rechecking_balance" ] ) double_the_number_of_seconds_to_wait = Number( $_GET[ "number_of_seconds_to_wait_before_rechecking_balance" ] ) * 2;
                if ( num % double_the_number_of_seconds_to_wait == 0 && wallet_identifier ) {
                    try {
                        getSpacechainBalance( localStorage[ "backup_words" ], wallet_identifier );
                    } catch ( e ) {}
                }
                //if there are no miners, try to resync every 5 seconds so that if they return you start syncing quickly
                if ( !$_GET[ "testing_no_sync" ] ) {
                    if ( !myminers.length && num % 10 == 0 ) setTimeout( function() {syncChain();}, 5000 );
                }
                //check for new blocks on startup and every 60 seconds thereafter
                if ( !num ) syncChain();
                if ( num == 120 ) {
                    num = 0;
                } else {
                    num = num + 1;
                }
                setTimeout( function() {checkHeartbeat( num );}, 500 );
            }
            checkHeartbeat( 0 );
        </script>
    </head>
    <body>
        <div class="home">
            <h1>Spacechain launcher</h1>
            <p>
                Welcome to the spacechain launcher. On this page you can launch your own bitcoin sidechain and start earning money from your users.
            </p>
            <p>
                To learn more about spacechains, peep these links:
            </p>
            <ul>
                <li><a href="https://www.youtube.com/watch?v=Ti1vRQMg_qE" target="_blank">Spacechains in 4 minutes video by Ruben Somsen</a></li>
                <li><a href="https://bitcoinmagazine.com/technical/how-bitcoin-spacechains-work" target="_blank">Spacechains article by Bitcoin Magazine</a></li>
            </ul>
            <p>
                Now let's get started! Click the button to make your own spacechain.
            </p>
            <p>
                <button class="launch_page_btn">Make a spacechain</button>
                <button class="view_first_spacechain">View the first spacechain</button>
            </p>
        </div>
        <div class="launch_page">
            <h1>Spacechain launcher</h1>
            <div class="launch_instructions">
                <p>
                    Creating your spacechain is a three step process.
                </p>
                <ol>
                    <li>Name your spacechain</li>
                    <li>Create the genesis block</li>
                    <li>Launch your network</li>
                </ol>
            </div>
            <div class="launch_step_1">
                <p class="step_1_title">
                    Step 1. Give your spacechain a name
                </p>
                <input class="name_your_spacechain" name="name_your_spacechain" placeholder="Best spacechain ever">
                <p>
                    And a genesis message
                </p>
                <textarea class="genesis_message_input" name="genesis_message_input" rows="8" placeholder="The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"></textarea>
                <p>
                    <button class="genesis_block_submit">Submit</button>
                </p>
            </div>
            <div class="launch_step_2">
                <p class="step_2_title">
                    Step 2. Create the genesis block, the first block of your sidechain
                </p>
                <div class="genesis_block_finalized">
                    <p class="genesis_block_title">
                        Your genesis block
                    </p>
                    <div class="genesis_block">
                        <p>Your spacechain's name</p>
                        <input disabled>
                        <p>Your spacechain's genesis message</p>
                        <textarea disabled rows="8"></textarea>
                    </div>
                </div>
                <div class="payment_div_container">
                    <p>
                        Please pay the following address. Your payment will anchor the first block of your sidechain directly into bitcoin's blockchain.
                    </p>
                    <div class="payment_div">
                        <a class="launch_payment_link" target="_blank"><div class="launch_payment_qr_code"></div></a>
                        <center class="launch_payment_caption_container">
                            <input class="launch_payment_caption" disabled>
                            <button class="launch_payment_copier" onclick='copyText( $( ".launch_payment_caption" ) );'>&#10063;</button>
                        </center>
                    </div>
                    <p>
                        Send <span class="launch_payment_amount"></span> sats to this address: <span class="launch_payment_address"></span>
                    </p>
                </div>
            </div>
            <div class="launch_step_3">
                <p class="step_3_title">
                    Step 3. Launch your network
                </p>
                <p class="behold_the_network">
                    Behold the network
                </p>
                <div class="prelaunchpad">
                    <p>
                        There <span class="is_or_are">are</span> currently <span class="num_of_miners">0</span> <span class="person_or_people">people</span> mining this spacechain, not counting yourself (if you are mining). Miners are who you get blocks from, so if no one is mining it, you will not see any blocks unless your browser downloaded them previously.
                    </p>
                    <div class="launchpad">
                        <button class="view_your_blockchain">View spacechain</button>
                        <button class="buy_and_sell_spacecoins">Buy and sell spacecoins</button>
                        <button class="manage_your_wallet">Manage your wallet</button>
                        <button class="mine_spaceblocks">Mining Center</button>
                    </div>
                </div>
            </div>
            <p class="newb_warning">
                <span style="font-weight: bold;">Read before clicking!</span> Your spacechain will be stored on *your computer only* until other people on your network download your blocks from you and validate them. Bitcoin miners won't serve your spacechain's blocks. (They don't even know your spacechain exists, because spacechains use *blind* merge mining.) If you make a spacechain, other people won't be able to view it or see it, even if you share a link to it, unless they have someone to get its blocks from. Therefore, I <span style="font-weight: bold;">strongly recommend</span> you register as a miner of your own spacechain in the Mining Center (you'll see it after you create your spacechain) and then keep the Mining Center open until many other people start mining your spacechain too. The way I coded this up, users of a spacechain can only get blocks by requesting them directly from miners of a spacechain (that can change in the future but it's how it works right now), and initially that's probably just going to be you. So if you close the Mining Center before anyone else is serving your blocks, no one will be able to view it. Just like how the bitcoin network would completely halt if all the nodes on the bitcoin network all turned off at the same time, your spacechain will appear completely blockless if no one is mining it and thus serving its blocks to your users.
            </p>
        </div>
        <div class="spaceblock_explorer">
            <p><button class="view_network">Back</button></p>
            <h1>Welcome to the spaceblock explorer</h1>
            <p class="spaceblocks_loading">Loading...<span class="spaceblocks_loading_percent">0</span>%</p>
            <div class="spaceblocks">
            </div>
        </div>
        <div class="mining_center">
            <h1>Welcome to the mining center</h1>
            <p><button class="view_network">Back</button></p>
            <div class="miner_registration"></div>
            <div class="hidden_mining_info">
                <p class="space_blocksheight">Blockheight: <span class="space_blockheight_count">0</span></p>
                <p>
                    Create next block
                </p>
                <p>
                    <h2>Transactions in block so far</h2>
                </p>
                <div class="messages_so_far">
                    <p class="none_so_far">
                        None so far
                    </p>
                </div>
                <textarea class="new_block_message_input" name="new_block_message_input" rows="8" placeholder="Any text is a transaction"></textarea>
                <p>
                    <button class="add_msg_to_block">Add transaction to block</button>
                </p>
                <p>
                    <button class="mine_new_block">Mine new block</button>
                </p>
            </div>
            <div class="new_block_payment_div_container">
                <p>
                    Please pay the following address. Your payment will anchor the next block of your sidechain directly into bitcoin's blockchain.
                </p>
                <div class="new_block_payment_div">
                    <a class="new_block_payment_link" target="_blank"><div class="new_block_payment_qr_code"></div></a>
                    <center class="new_block_payment_caption_container">
                        <input class="new_block_payment_caption" disabled>
                        <button class="new_block_payment_copier" onclick='copyText( $( ".new_block_payment_caption" ) );'>&#10063;</button>
                    </center>
                </div>
                <p>
                    Send <span class="new_block_payment_amount"></span> sats to this address: <span class="new_block_payment_address"></span>
                </p>
            </div>
        </div>
        <div class="pegzone">
            <h1>Buy and sell</h1>
            <p><button onclick='window.location.href = window.location.href = window.location.protocol + "//" + window.location.hostname + window.location.pathname + "?chain=" + $_GET[ "chain" ] + `&wallet_id=${$_GET[ "wallet_id" ]}`;'>Back</button></p>
            <h2>Orderbook</h2>
            <p>
                Buy and sell spacecoins
            </p>
            <div class="orderbook">
            </div>
            <button class="make_offer">Make an offer (this button doesn't work yet)</button> 
        </div>
        <div class="spacecoin_offer">
            <h1>Spacecoin offer</h1>
            <p><button onclick='$( ".spacecoin_offer" ).style.display = "none";$( ".buy_and_sell_spacecoins" ).click();'>Back</button></p>
            <div class="offer_details"></div>
            <p>
                How many spacecoins do you want to buy from this seller?
            </p>
            <p><input class="spacecoins_to_buy" type="number" step="1" min="546" value="546"></p>
            <p>
                Paste a spacechain address
            </p>
            <p><input class="post_burn_spacechain_address"></p>
            <button class="accept_offer">Accept this offer</button>
            <div class="burn_payment_div_container">
                <p>
                    Please pay the following address.
                </p>
                <div class="burn_payment_div">
                    <a class="burn_payment_link" target="_blank"><div class="burn_payment_qr_code"></div></a>
                    <center class="burn_payment_caption_container">
                        <input class="burn_payment_caption" disabled>
                        <button class="burn_payment_copier" onclick='copyText( $( ".burn_payment_caption" ) );'>&#10063;</button>
                    </center>
                </div>
                <p>
                    Send <span class="burn_payment_amount"></span> sats to this address: <span class="burn_payment_address"></span>
                </p>
            </div>
        </div>
        <div class="spacechain_wallet">
            <h1>Wallet</h1>
            <p><button class="view_network">Back</button></p>
            <p>
                Syncing utxo set: <span class="syncing_utxos">synced</span>
            </p>
            <p>
                Assaying transactions from this block: <span class="assay_block">none (this will update as the syncing process moves from block to block)</span>
            </p>
            <p>
                Balance: <span class="spacecoin_balance">loading... (this will load about a minute after the utxo set syncs)</span>
            </p>
            <button class="send_on_spacechain">Send</button> <button class="receive_on_spacechain">Receive</button>
            <br><br>
            <div class="spacecoin_payment_div_container">
                <div class="spacecoin_payment_div">
                    <a class="spacecoin_payment_link" target="_blank"><div class="spacecoin_payment_qr_code"></div></a>
                    <center class="spacecoin_payment_caption_container">
                        <input class="spacecoin_payment_caption" disabled>
                        <button class="spacecoin_payment_copier" onclick='copyText( $( ".spacecoin_payment_caption" ) );'>&#10063;</button>
                    </center>
                </div>
            </div>
            <div class="send_money_form">
                <p>Address</p>
                <p><input class="spacechain_to_address" placeholder="sc1hg57vxlg9szt04h0lk7dq3vwsmkrepaw29gkdx"></p>
                <p>Amount (in spacecoins)</p>
                <p><input type="number" class="spacechain_to_amount" step="1"></p>
                <p><input type="number" class="spacechain_fee_amount" step="1" value="50" min="1"></p>
                <p><button class="submit_send_on_spacechain_form">Submit</button></p>
            </div>
        </div>
        <script>
            if ( $_GET[ "chain" ] ) $( '.newb_warning' ).onload = $( '.newb_warning' ).style.display = "none";
            $( '.launch_page_btn' ).onclick = async function() {
                $( '.home' ).style.display = "none";
                $( '.launch_page' ).style.display = "block";
                await prepareAnchor();
            }
            $( '.view_first_spacechain' ).onclick = async function() {
                var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname +
                "?chain=" + "25594d702f285977c5c127bb4b6dc9564b73f82ae67a39b5ec8743ffbba554d6";
                if ( $_GET[ "testing_wallet" ] ) url += "&wallet_id=" + "5c2dfbbfb0cafe0c56efec3fcf9a83a776f13173338ddc2cb8ced74152d320be";
                window.location.href = url;
            }
            $( '.genesis_block_submit' ).onclick = async function() {
                var conf = confirm( `Are you sure you want to use this data? \n\nName: ${$( '.name_your_spacechain' ).value}\nMessage: ${$( '.genesis_message_input' ).value}` );
                if ( !conf ) return;
                $( '.launch_step_1' ).style.display = "none";
                $( '.genesis_block_finalized' ).style.display = "block";
                $( '.payment_div_container' ).style.display = "block";
                $( '.genesis_block_finalized .genesis_block input' ).value = $( '.name_your_spacechain' ).value;
                $( '.genesis_block_finalized .genesis_block textarea' ).value = $( '.genesis_message_input' ).value;
            }
            $( '.view_your_blockchain' ).onclick = async function() {
                if ( !spacechain.length ) {
                    var message = `You have not yet synced any blocks in this blockchain, please try again in a few seconds`;
                    if ( !myminers.length ) {
                        message = `No one is mining this spacechain and miners are who you get blocks from so you can't explore this blockchain until someone with at least one of its blocks starts mining`;
                    } else {
                        syncChain();
                    }
                    alert( message );
                    return;
                }
                var block = spacechain[ spacechain.length - 1 ][ 0 ];
                var index = spacechain.length - 1;
                showBlockInExplorer( block, index );
            }
            $( '.mine_spaceblocks' ).onclick = async function() {
                if ( $_GET[ "wallet_id" ] ) {
                    sessionStorage[ `coinbase_for_block_${getSpacechainHashes().length + 1}` ] = "[]";
                    var wallet_identifier = $_GET[ "wallet_id" ];
                    if ( localStorage[ `utxo_set_for_${wallet_identifier}` ] ) {
                        var utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                        var working_utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                        var offset = 0;
                        utxo_set.forEach( function( utxo, index ) {
                            if ( utxo.startsWith( String( getSpacechainHashes().length  + 1 ) ) ) {
                                working_utxo_set.splice( index - offset, 1 );
                                offset = offset + 1;
                            }
                        });
                        localStorage[ `utxo_set_for_${wallet_identifier}` ] = JSON.stringify( working_utxo_set );
                    }
                }
                $( '.launch_page' ).style.display = "none";
                $( '.new_block_payment_div_container' ).style.display = "none";
                $( '.mining_center' ).style.display = "block";
                $( '.space_blockheight_count' ).innerText = String( getSpacechainHashes().length );
                $( '.new_block_message_input' ).value = "";
                if ( !sessionStorage[ "mining" ] ) {
                    var button = document.createElement( "button" );
                    button.innerText = "Register as a miner of this spacechain";
                    button.onclick = function() {startMining();}
                    $( '.miner_registration' ).innerHTML = "";
                    $( '.miner_registration' ).append( button );
                    $( '.mine_new_block' ).style.display = "none";
                } else {
                    var button = document.createElement( "button" );
                    button.innerText = "Deregister as a miner of this spacechain";
                    button.onclick = function() {stopMining();}
                    $( '.miner_registration' ).innerHTML = "";
                    $( '.miner_registration' ).append( button );
                    $( '.mine_new_block' ).style.display = "inline";
                    $( '.hidden_mining_info' ).style.display = "block";
                }
            }
            $( '.add_msg_to_block' ).onclick = async function() {
                if ( $( '.none_so_far' ) ) $( '.none_so_far' ).style.display = "none";
                var msg = $( '.new_block_message_input' ).value;
                var userdata = JSON.parse( sessionStorage[ "userdata" ] );
                //if the transaction pretends to be a coinbase, ignore it
                if ( isValidJson( msg ) && Object.keys( JSON.parse( msg ) ).includes( "inputs" ) && Array.isArray( JSON.parse( msg )[ "inputs" ] ) && !JSON.parse( msg )[ "inputs" ].length ) return;
                if ( sessionStorage[ "mining" ] && $_GET[ "wallet_id" ] ) {
                    //without adding its transactions to the utxo set, check if the transaction is valid
                    var wallet_identifier = $_GET[ "wallet_id" ];
                    var tx_is_good = await transactionIsValidWalletTx( msg, true, wallet_identifier, 1, 1, true );
                    //ignore the transaction if it is no good, otherwise continue
                    if ( tx_is_good ) {
                        var transaction = JSON.parse( msg );
                        //ensure the value matches the difference between the inputs minus the outputs
                        var sum_of_all_outputs = 0;
                        transaction[ "outputs" ].forEach( function( output ) {
                            sum_of_all_outputs = sum_of_all_outputs + output[ "value" ];
                        });
                        var sum_of_all_inputs = 0;
                        transaction[ "inputs" ].forEach( function( input ) {
                            sum_of_all_inputs = sum_of_all_inputs + input[ "value" ];
                        });
                        var my_fee = sum_of_all_inputs - sum_of_all_outputs;
                        //if the transaction does not pay you, do not mine it
                        if ( !my_fee ) return;
                        //check if the current block has a coinbase transaction for this wallet that pays me
                        if ( sessionStorage[ `coinbase_for_block_${getSpacechainHashes().length + 1}` ] == "[]" ) {
                            //if it does not, add that first, then add this transaction
                            var mycoinbase_prep = {}
                            mycoinbase_prep[ "wallet" ] = wallet_identifier;
                            mycoinbase_prep[ "inputs" ] = [];
                            var outputs = [];
                            var addy = await getSecondUnusedSpacechainChangeAddress( localStorage[ "backup_words" ], wallet_identifier );
                            var scripthash = bech32ToHex( addy );
                            outputs.push( {"scripthash":scripthash,"value":sum_of_all_inputs - sum_of_all_outputs} );
                            mycoinbase_prep[ "outputs" ] = outputs;
                            mycoinbase_prep[ "timelock" ] = 1;
                            var mycoinbase = JSON.stringify( mycoinbase_prep );
                            sessionStorage[ `coinbase_for_block_${getSpacechainHashes().length + 1}` ] = mycoinbase;
                            userdata.push( mycoinbase );
                            sessionStorage[ "userdata" ] = JSON.stringify( userdata );
                            //add the new utxos to your utxo set
                            if ( !localStorage[ `utxo_set_for_${wallet_identifier}` ] ) {
                                var utxo_set = [];
                            } else {
                                var utxo_set = JSON.parse( localStorage[ `utxo_set_for_${wallet_identifier}` ] );
                            }
                            var index_of_coinbase = userdata.indexOf( mycoinbase );
                            if ( !utxo_set.includes( String( getSpacechainHashes().length + 1 ) + ":" + String( userdata.length - 1 ) + ":0" ) ) {
                                utxo_set.push( String( getSpacechainHashes().length + 1 ) + ":" + String( userdata.length - 1 ) + ":0" );
                            }
                            localStorage[ `utxo_set_for_${wallet_identifier}` ] = JSON.stringify( utxo_set );
                            await transactionIsValidWalletTx( msg, true, wallet_identifier, getSpacechainHashes().length + 1, userdata.length );
                        } else {
                            //otherwise, modify the coinbase transaction, then add this transaction
                            var oldcoinbase = sessionStorage[ `coinbase_for_block_${getSpacechainHashes().length + 1}` ];
                            newcoinbase = JSON.parse( oldcoinbase );
                            oldcoinbase = JSON.parse( oldcoinbase );
                            newcoinbase.outputs[ 0 ][ "value" ] = oldcoinbase.outputs[ 0 ][ "value" ] + my_fee;
                            //find the old coinbase
                            var index_of_old_coinbase = userdata.indexOf( JSON.stringify( oldcoinbase ) );
                            //replace it with the new one
                            userdata.splice( index_of_old_coinbase, 1, JSON.stringify( newcoinbase ) );
                            sessionStorage[ "userdata" ] = JSON.stringify( userdata );
                            //add the new utxos to your utxo set
                            await transactionIsValidWalletTx( msg, true, wallet_identifier, getSpacechainHashes().length + 1, userdata.length );
                        }
                    }
                }
                userdata.push( msg );
                sessionStorage[ "userdata" ] = JSON.stringify( userdata );
                $( '.new_block_message_input' ).value = "";
                $( '.messages_so_far' ).innerHTML = ``;
                userdata.forEach( function( item ) {
                    $( '.messages_so_far' ).innerHTML += `<p>${item}</p>`;
                });
            }
            $( '.mine_new_block' ).onclick = async function() {
                //prepare data
                var userdata = JSON.parse( sessionStorage[ "userdata" ] );
                //generate the block
                console.log( userdata );
                var [ hash, block ] = await generateBlock( userdata, getSpacechainHashes()[ getSpacechainHashes().length - 1 ] );
                console.log( "the awesome block:", block );
                var is_candidate_block = await isCandidateBlock( JSON.stringify( block ) );
                if ( !is_candidate_block ) {
                    alert( "Oh no! Something went wrong, please try again" );
                    return;
                }
                console.log( hash, block );
                sessionStorage[ "spaceblock_hash" ] = hash;
                sessionStorage[ "next_spaceblock" ] = JSON.stringify( block );
                $( '.new_block_payment_div_container' ).style.display = "block";
                //ask for payment, then do this part
                await prepareAnchor();
            }
            $$( '.view_network' ).forEach( function( item ) {
                item.onclick = function() {view_network_home();}
            });
            $( '.buy_and_sell_spacecoins' ).onclick = async function() {
                $( '.launch_page' ).style.display = "none";
                $( '.pegzone' ).style.display = "block";
                $( '.orderbook' ).innerHTML = ``;
                var offer = document.createElement( "div" );
                offer.style = "border: 1px solid black; padding: 10px; margin: 10px;";
                offer.className = "sell_offer";
                var pgraph = document.createElement( "p" );
                pgraph.innerHTML = `Seller: <span class="buyer">The Void</span>`;
                offer.append( pgraph );
                var pgraph = document.createElement( "p" );
                pgraph.innerHTML = `Amount: <span class="min">546</span> - <span class="max">100,000,000,000</span> sats`;
                offer.append( pgraph );
                var pgraph = document.createElement( "p" );
                pgraph.innerHTML = `Fee type: <span class="orderbook_fee_type">Absolute</span>`;
                offer.append( pgraph );
                var pgraph = document.createElement( "p" );
                pgraph.innerHTML = `Fee: <span class="orderbook_fee">loading...</span>`;
                offer.append( pgraph );
                var anchor = document.createElement( "a" );
                //I don't want to put the "chain" element in the next url because then when I load it, it will load view_network_home...but
                var url = window.location.protocol + "//" + window.location.hostname + window.location.pathname + `?offer=${$_GET[ "chain" ]}&chain=${$_GET[ "chain" ]}`;
                if ( $_GET[ "wallet_id" ] ) url += "&wallet_id=" + $_GET[ "wallet_id" ];
                anchor.href = url;
                var button = document.createElement( "button" );
                button.innerText = "View offer";
                anchor.append( button );
                offer.append( anchor );
                $( '.orderbook' ).append( offer );
                var feerate = await getMinFeeRate();
                var fee = 300 * feerate;
                $( '.orderbook_fee' ).innerText = String( fee ) + " sats";
            }
            $( '.accept_offer' ).onclick = async function() {
                var spacechain_address = $( '.post_burn_spacechain_address' ).value;
                if ( spacechain_address.startsWith( "spacechain:" ) ) spacechain_address = spacechain_address.substring( 11 );
                try {
                    spacechain_address = bech32ToHex( spacechain_address );
                } catch( e ) {
                    alert( "something went wrong, please enter a valid spacechain address with no typos and then try again." );
                    return;
                }
                var spacechain_anchor_txid = $_GET[ "chain" ];
                //prepare the op_return
                var op_return = spacechain_address + spacechain_anchor_txid;
                if ( !isHex( op_return ) || op_return.length != 104 ) {
                    alert( "something went wrong, make sure you enter a valid spacechain address and please try again." );
                    return;
                }
                var keypair = bitcoinjs.ECPair.makeRandom();
                var privkey = keypair.privateKey.toString( "hex" );
                var pubkey = keypair.publicKey.toString( "hex" );
                var feerate = await getMinFeeRate();
                var amount_to_burn_plus_fee = Number( $( '.spacecoins_to_buy' ).value ) + ( 300 * feerate );
                var amount_to_burn = Number( $( '.spacecoins_to_buy' ).value );
                var blockheight = await getBlockheight();
                var timelock = blockheight + 2016;
                var preimage = bitcoinjs.ECPair.makeRandom().privateKey.toString( "hex" );
                var payment_hash = bitcoinjs.crypto.sha256( hexToBytes( preimage ) ).toString( "hex" );
                var swap_address = getSwapAddress( pubkey, pubkey, payment_hash, timelock );
                sessionStorage[ "utxo_data" ] = JSON.stringify( {"privkey":privkey,"pubkey":pubkey,"preimage":preimage,"pmthash":payment_hash,"timelock":timelock,"amount":amount_to_burn_plus_fee} );
                $( '.burn_payment_qr_code' ).innerHTML = ``;
                $( '.burn_payment_qr_code' ).append( createQR( swap_address.toUpperCase() ) );
                $( '.burn_payment_link' ).href = "bitcoin:" + swap_address;
                $( '.burn_payment_caption' ).value = "bitcoin:" + swap_address;
                $( '.burn_payment_amount' ).innerText = amount_to_burn_plus_fee;
                $( '.burn_payment_address' ).innerText = swap_address;
                $( '.burn_payment_div_container' ).style.display = "block";
                var txid = await waitThenBurn( swap_address, amount_to_burn_plus_fee, preimage, privkey, pubkey, timelock, pubkey, op_return, amount_to_burn );
                if ( !isHex( txid ) || txid.length != 64 ) {
                    alert( "Oh no, something went wrong! Please try again." );
                    return;
                }
                alert( "success! Your spacecoins will be available in the spacechain address you designated as soon as this transaction is confirmed: " + txid );
            }
            $( '.manage_your_wallet' ).onclick = function() {
                $( '.launch_page' ).style.display = "none";
                $( '.spacecoin_payment_div_container' ).style.display = "none";
                $( '.spacecoin_payment_qr_code' ).innerHTML = ``;
                $( '.send_money_form' ).style.display = "none";
                $( '.spacechain_to_address' ).value = "";
                $( '.spacechain_to_amount' ).value = "";
                $( '.spacechain_wallet' ).style.display = "block";
            }
            $( '.receive_on_spacechain' ).onclick = async function() {
                $( '.send_money_form' ).style.display = "none";
                $( '.spacechain_to_address' ).value = "";
                $( '.spacechain_to_amount' ).value = "";
                $( '.spacecoin_payment_div_container' ).style.display = "block";
                $( '.spacecoin_payment_caption' ).value = "loading...";
                var wallet_identifier = $_GET[ "wallet_id" ];
                var first_unused_address = await getFirstUnusedSpacechainAddress( localStorage[ "backup_words" ], wallet_identifier );
                $( '.spacecoin_payment_qr_code' ).innerHTML = ``;
                $( '.spacecoin_payment_qr_code' ).append( createQR( first_unused_address ) );
                $( '.spacecoin_payment_link' ).href = "spacechain:" + first_unused_address;
                $( '.spacecoin_payment_caption' ).value = "spacechain:" + first_unused_address;
            }
            $( '.send_on_spacechain' ).onclick = async function() {
                if ( !sessionStorage[ "my_utxos" ] || sessionStorage[ "my_utxos" ] == "[]" ) {
                    alert( "you have nothing to spend, wait to sync or fund your wallet" );
                    return;
                }
                $( '.spacecoin_payment_div_container' ).style.display = "none";
                $( '.spacechain_to_address' ).value = "";
                $( '.spacechain_to_amount' ).value = "";
                $( '.send_money_form' ).style.display = "block";
            }
            $( '.submit_send_on_spacechain_form' ).onclick = async function() {
                var spacechain_address = $( '.spacechain_to_address' ).value;
                if ( spacechain_address.startsWith( "spacechain:" ) ) spacechain_address = spacechain_address.substring( 11 );
                var wallet_identifier = $_GET[ "wallet_id" ];
                var this_address_once_had_money = await thisSpacechainAddressOnceHadMoney( spacechain_address, wallet_identifier );
                if ( this_address_once_had_money ) {
                    alert( "Something went wrong, that spacechain address was already used. Enter a fresh one and then try again." );
                    return;                    
                }
                try {
                    var scripthash = bech32ToHex( spacechain_address );
                } catch( e ) {
                    alert( "Something went wrong, please enter a valid spacechain address with no typos and then try again." );
                    return;
                }
                var to_amount = $( '.spacechain_to_amount' ).value;
                to_amount = Number( to_amount );
                var fee_amount = $( '.spacechain_fee_amount' ).value;
                fee_amount = Number( fee_amount );
                if ( !fee_amount ) {
                    alert( "Something went wrong, please enter a fee above 0. Recommended fee: 50 spacecoins" );
                    return;
                }
                if ( !to_amount || String( to_amount ).includes( "." ) || to_amount + fee_amount > Number( $( '.spacecoin_balance' ).innerText.substring( 0, $( '.spacecoin_balance' ).innerText.indexOf( " " ) ) ) ) {
                    alert( "Something went wrong, please enter a valid amount with no decimals and less than your total balance, then try again. Also remember to account for the fee." );
                    return;
                }
                var my_utxos = JSON.parse( sessionStorage[ "my_utxos" ] );
                var inputs = [];
                var amount_reached = 0;
                my_utxos.every( function( utxo ) {
                    amount_reached = amount_reached + utxo[ "value" ];
                    var input = {}
                    input[ "output_index" ] = utxo[ "output_index" ];
                    console.log( "input:", input, "utxo:", utxo );
                    input[ "value" ] = utxo[ "value" ];
                    input[ "redeem_script" ] = "";
                    if ( utxo[ "burntx" ] ) {
                        input[ "burntx" ] = utxo[ "burntx" ];
                    } else {
                        input[ "blocknum" ] = Number( utxo[ "blocknum" ] );
                        input[ "tx_index" ] = Number( utxo[ "tx_index" ] );
                    }
                    inputs.push( input );
                    if ( amount_reached >= to_amount + fee_amount ) return;
                    return true;
                });
                var outputs = [];
                var output_1 = {
                    "scripthash": scripthash,
                    "value": to_amount
                }
                outputs.push( output_1 );
                var sum_of_all_inputs = 0;
                inputs.forEach( function( input ) {
                    sum_of_all_inputs = sum_of_all_inputs + input[ "value" ];
                });
                var change_amount = sum_of_all_inputs - ( outputs[ 0 ][ "value" ] + fee_amount );
                if ( change_amount ) {
                    var change_address = await getFirstUnusedSpacechainChangeAddress( localStorage[ "backup_words" ], wallet_identifier );
                    var output_2 = {
                        "scripthash": bech32ToHex( change_address ),
                        "value": change_amount
                    }
                    outputs.push( output_2 );
                }
                var unsigned_tx = {}
                unsigned_tx[ "wallet" ] = wallet_identifier;
                unsigned_tx[ "inputs" ] = inputs;
                unsigned_tx[ "outputs" ] = outputs;
                unsigned_tx[ "timelock" ] = 1;

                var tx_to_sign = JSON.parse( JSON.stringify( unsigned_tx ) );
                tx_to_sign[ "inputs" ].forEach( function( input ) {delete input[ "redeem_script" ];});
                var sighash = bitcoinjs.crypto.sha256( JSON.stringify( tx_to_sign ) );
                var signed_tx = JSON.parse( JSON.stringify( unsigned_tx ) );
                signed_tx[ "inputs" ].forEach( function( input, index ) {
                    var oldpriv = my_utxos[ index ][ "privkey" ];
                    var locking_script_hex = getLockingScriptHexFromPrivkey( oldpriv );
                    var keys = bitcoinjs.ECPair.fromPrivateKey( Buffer.from( oldpriv, "hex" ) );
                    var sig = keys.sign( sighash, true );
                    var witness_stack = [
                        sig.toString( "hex" ) + "-[*]-[*]",
                        keys.publicKey.toString( "hex" ),
                        locking_script_hex
                    ];
                    witness_stack = btoa( JSON.stringify( witness_stack ) );
                    input[ "redeem_script" ] = witness_stack;
                });
                var tx = JSON.stringify( signed_tx );
                var tx_is_valid = await transactionIsValidWalletTx( tx, true, wallet_identifier, 1, 1, true );
                if ( !tx_is_valid ) {
                    console.log( "signed but invalid tx:", tx );
                    alert( "oh no, the tx you created was invalid! Please try again, and if this error persists, ask a developer for help." );
                    return;
                }
                console.log( "signed and validated tx:", tx );
                if ( !myminers.length && !sessionStorage[ "mining" ] ) {
                    alert( "You cannot broadcast this transaction right now because there are no miners and therefore no one will pick it up and mine it. Try again later or register as a miner yourself." );
                    return;
                } else {
                    $( '.spacechain_wallet' ).style.display = "none";
                    $( '.mining_center' ).style.display = "block";
                    $( '.new_block_message_input' ).value = tx;
                    $( '.add_msg_to_block' ).click();
                    return;
                }
                myminers.forEach( async function( miner, index ) {
                    var message = {}
                    message[ "msg_type" ] = "broadcast_tx";
                    message[ "tx" ] = tx;
                    message = JSON.stringify( message );
                    var recipient = miner[ 0 ];
                    var encrypted = encrypt( privKey, recipient, message );
                    var event = {
                        "content"    : encrypted,
                        "created_at" : Math.floor( Date.now() / 1000 ),
                        "kind"       : 20004,
                        "tags"       : [ [ 'p', recipient ] ],
                        "pubkey"     : pubKey,
                    }
                    var signedEvent = await getSignedEvent( event, privKey );
                    socket.send( JSON.stringify( [ "EVENT", signedEvent ] ) );
                });
                alert( "Your transaction was broadcasted, please wait for it to confirm" );
            }
        </script>
    </body>
</html>
